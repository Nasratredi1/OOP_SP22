public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
   }
}

// variable declarition in java
// Note: Java is casesensitive language please be careful when you are creating variable .
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = 20;
        System.out.println(myFirstNumber);// you can write Sout then tab to print all
    }
}
//
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = 10+5;
        System.out.println(myFirstNumber);// you can write Sout then tab to print all
    }
}
//
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = (10+5) + (2*10);
        System.out.println(myFirstNumber);// you can write Sout then tab to print all
    }
}
//
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = (10+5) + (2*10);
        int mySecondNumber = 12;
        int myThirdNumber = 6;
        int myTotal = myFirstNumber + mySecondNumber + myThirdNumber;
        System.out.println(myTotal);// you can write Sout then tab to print all


    }
}
//
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = (10+5) + (2*10);
        int mySecondNumber = 12;
        int myThirdNumber = myFirstNumber *2;
        int myTotal = myFirstNumber + mySecondNumber + myThirdNumber;
        System.out.println(myTotal);// you can write Sout then tab to print all


    }
}
// Find the deffrence b/w 1000  and 117 for this we create another variable .
public class Hello {
    public static void main(String[] args)
    {
        System.out.println("Hello, Nasrat!");
        int myFirstNumber = (10+5) + (2*10);
        int mySecondNumber = 12;
        int myThirdNumber = myFirstNumber *2;
        int myTotal = myFirstNumber + mySecondNumber + myThirdNumber;
        int myLastOne = 1000 - myTotal;
        System.out.println(myLastOne);// you can write Sout then tab to print all


    }
}

//
package com.Johnredi;

public class Main {

    public static void main(String[] args) {
        // int has a width of 32  = 2^32
        int myMinvalue= -2_147_483_648;
        int myMaxvalue=  2_147_483_647;
        int myTotal = (myMinvalue/2);
        System.out.println("myTotal =" + myTotal);//for printing the myTotal value.

        //byte has a width of 8
        byte myBytevalue = -128;
        byte myNewByteValue = (byte ) (myBytevalue/2);// For Converting Integer value to byte you must cast the value to byte otherwise there is an error.
        System.out.println("myNewByteValue = " + myNewByteValue);
        //short has a width of 16
        short myShortValue = 32767;
        short myNewShortValue = (short) (myShortValue / 2);
        // long has a width of 64 the number is 2 power 63 which is so big number.
        long myLongValue = 9_223_372_036_854_775_807L; // This is important to write L with long.


    }
}
// float and double
package com.company;

public class Main {

    public static void main(String[] args) {
        int myIntValue = 5;
        float myFloatValue = 5f;// f writting b/c it's single precision if you not write then that's way also correct.
        double myDoubleValue = 5d;
        System.out.println("myIntValue = "+myIntValue);
        System.out.println("myFloatValue = "+myFloatValue);
        System.out.println("myDoubleValue = "+myDoubleValue);



    }
}
package com.company;

public class Main {

    public static void main(String[] args) {
        int myIntValue = 5/2;// that not take reminder value they print 2
        float myFloatValue = 5f/2f;// f writting b/c it's single precision if you not write then that's way also correct.
        double myDoubleValue = 5d/2d;// print 2.5
        System.out.println("myIntValue = "+myIntValue);
        System.out.println("myFloatValue = "+myFloatValue);
        System.out.println("myDoubleValue = "+myDoubleValue);



    }
}
//
package com.company;

public class Main {

    public static void main(String[] args) {
        //width of int = 32 (4 bytes)
        int myIntValue = 5/2;// that not take reminder value they print 2
        //width of float = 32 (4 bytes) after comma print 8 value
        float myFloatValue = 5f/2f;// f writting b/c it's single precision if you not write then that's way also correct.
        //width of Double = 64 (8 bytes) after comma print 16 value
        double myDoubleValue = 5d/2d;// print 2.5
        System.out.println("myIntValue = "+myIntValue);
        System.out.println("myFloatValue = "+myFloatValue);
        System.out.println("myDoubleValue = "+myDoubleValue);
   }
}
package com.company;

public class Main {

    public static void main(String[] args) {
        // write a program
        // Convert a given number of pounds to kilograms
        // 1: Create a variable to store the number of pounds
        // 2:Calculate the number of kilograms for the number above and store in a variable
        // 3: Print out the result.
        // Hint: 1 pound is equall to 0.45359237 kilograms.
        //
        // Note from d java knows it's a double
        double numPounds = 200d;
        double convertedKilograms = numPounds *0.45359237d;
        System.out.println("Kilograms = "+ convertedKilograms);
        // 90.718474



    }
}
// boolean and char
package com.company;

public class Main {

    public static void main(String[] args) {
        // write a program
        // Convert a given number of pounds to kilograms
        // 1: Create a variable to store the number of pounds
        // 2:Calculate the number of kilograms for the number above and store in a variable
        // 3: Print out the result.
        // Hint: 1 pound is equall to 0.45359237 kilograms.
        //
        // Note from d java knows it's a double
        double numPounds = 200d;
        double convertedKilograms = numPounds *0.45359237d;
        System.out.println("Kilograms = "+ convertedKilograms);
        // 90.718474



    }
}
// boolean and char
package com.john;

public class Main {

    public static void main(String[] args) {

        char myChar = 'A';// you can write only one character at a time
        char myChar2 = '\u00A9';// that is called unicode
        System.out.println("Unicode output was : "+ myChar2);

        boolean myBoolean = false;
        boolean isMale = true;

    }
}
//
package com.john;

public class Main {

    public static void main(String[] args) {
     // list of primitive datatype that we have discussed till now
        // byte
        //short
        // int
        //long
        //float
        //double
        //char
        //boolean
        // String like class
        String myString = "This is my string";
        System.out.println("myString is equall to "+ myString);
        myString = myString + "and this is more.";
        System.out.println("myString is equall to "+ myString);
        myString = myString +"\u00A9 2020";
        System.out.println("myString is equall to "+ myString);

        String numberString = "250,55";
        numberString =numberString + "49,95"; //they are printed like a text
        System.out.println("The result is "+ numberString);

        String lastString ="10";
        int myInt = 50;
        lastString = lastString +myInt;
        System.out.println("LastString is equal to "+ lastString);

        double doubleNumber = 120.47;
        lastString = lastString +doubleNumber;
        System.out.println("LastString value is  "+ lastString);


    }
}
// Operator in Java

package com.john;

public class Main {

    public static void main(String[] args) {
	 int result = 1 + 2;// 1 and 2 is operand and + operator
        System.out.println("1 + 2  = "+ result);

        int previousResult = result;
        result = result - 1;
        System.out.println(previousResult +" - 1 =" + result);

        previousResult = result;
        result = result * 10;
        System.out.println(previousResult +" * 10 =" + result);

        previousResult =result;

        result = result / 5;
        System.out.println(previousResult +" / 5 =" + result);

        previousResult =result;

        result = result % 3;
        System.out.println(previousResult +" % 3 =" + result);

        previousResult =result;

        result = result + 1;
        System.out.println("Result is now " +  result);
        result ++; // for above we can use this shortcut.
        System.out.println("Result is now " +  result);
        result --;
        System.out.println("Result is now " +  result);

        result +=2;
        System.out.println("Result is now " +  result);

        result *=10;
        System.out.println("Result is now " +  result);

        result -=10;
        System.out.println("Result is now " +  result);

        result /=10;
        System.out.println("Result is now " +  result);

        boolean isAhmad = false;
        // now condition is false they not print any thing in monitor
                if(isAhmad == true)// when i write in place of true false  then they print below line
                    System.out.println("It is not an Ahmed");
        int topScore = 90;
        if (topScore == 100)
            System.out.println("You got the high score!");
            // not printing this line b/c cond is false.
        if (topScore != 100)//
            System.out.println("You got the high score!");
        // not print
        if (topScore > 100)//
            System.out.println("You got the high score!");
        // print the result
        if (topScore >= 100)//
            System.out.println("You got the high score!");

        // not print
        if (topScore < 100)//
            System.out.println("You got the high score!");
        // print the result
        if (topScore <= 100)//
            System.out.println("You got the high score!");
  // && Operator both condition must be true
         int secondTopScore = 60;
        if ((topScore > secondTopScore) && (topScore<100))
            System.out.println("Greater than top score and less than 100");


//






    }
}

// Projct name : KeywordsAndExpression
package com.john;

public class Main {

    public static void main(String[] args) {
        // a mile is equal to 1.609344 kilometres
        double kilometres = (100* 1.609344);
        int highScore = 50;

        if(highScore == 50){ // within brackets code is called expression
            System.out.println("This is an Expression");
        }


    }
}
         // In the following code that I will type below, Write down what parts of the code
         // are Expression
         int score = 100;
         if (score > 99){
                 System.out.println("You ot the high score!");
                 score = 0;

         }

// Project name : StatementWhiteSpacesAndIndenting.
package com.john;

public class Main {

    public static void main(String[] args) {
        int myVariable = 50;
        myVariable++;
        myVariable--;
        System.out.println("This is a test");

        System.out.println("This is " +
                "another" +
                "Still more.");
        // You can write like this but this is not readable
        int anotherVariable = 50;
        myVariable--;
        System.out.println("This is another One");

    }
}

//Project Name :IfKeywordsAndCodeblocks
package com.john;

public class Main {

    public static void main(String[] args) {
        boolean gameOver = true;
        int score = 5000;
        int levelCompleted = 5;
        int bonus = 100;


//        if (score == 4000)// when the condition is true all the thing is executed
//           // which is wthin the brackets. otherwise below line is  line is execute.
//            // first line will not execute.
//        {tem.out.println("Your Score was 5000");// It's good to use Brackets if you want
//            // to readable your code for your audience.
//        }
//        System.out.println("This was executed");
//        if(score <5000 && score>1000)
//        {
//            System.out.println("Your score was less than 5000 but greater than 1000");
//        }
//        else if(score > 1000) {
//            System.out.println("Your score was less than 1000");
//        }
//        else{
//            System.out.println("Got here");
//        }
        if (gameOver == true){// this is same too if (gameOver)
            int finalScore = score + (levelCompleted * bonus);
            finalScore +=1000;
            System.out.println("Your final score was " + finalScore);
        }
        // within bracket code is called schoop.boolean gameOver = true;

        /*exercise
        print out a second score on the secreen with the following
        score set to 10000
        leverlCompleted set to 8
        bonus set to 200
        But make sure the first printout above still displays as well
         */
        // We have two ways to solve this question
        // first way
//        boolean newGameOver = true;
//        int newScore = 10000;
//        int newLevelCompleted = 8;
//        int newBonus = 200;
//        if (newGameOver == true){
//            int finalScore = newScore + (newLevelCompleted * newBonus);
//            System.out.println("Your final score was " + finalScore);
//        }
        // 2nd way solution Takes all above variable and just chage the value of a variable
        // this way is best b/c we are not westing more memory.
        score = 10000;
        levelCompleted = 8;
        bonus = 200;
        if (gameOver ){
            int finalScore = score + (levelCompleted * bonus);
            System.out.println("Your final score was " + finalScore);
        }



    }
}

// Methods.
// // program: when you want to not declare a variable and you pass the value on calling time.
package com.john;

public class Main {

    public static void main(String[] args) {

        calculateScore(true,800,5,100);

        calculateScore(true,10000,8,200);

    public static void calculateScore(boolean gameOver, int score, int levelCompleted, int bonus)
    {
        if (gameOver)
        {
            int finalScore = score + (levelCompleted * bonus);
            finalScore += 1000;
            System.out.println("Your final score was " + finalScore);
        }

    }
}

// when we pass a paramater than we don't need to declare varibale again and again.

// or if you don't want to pass value when you call to a function  for this you must declare a variable

// program: when you want to not declare a variable and you pass the value on calling time.
package com.john;

public class Main {

    public static void main(String[] args) {
        boolean gameOver = true;
        int score = 800;
        int levelCompleted = 5;
        int bonus = 100;


        int highScore= calculateScore(gameOver, score, levelCompleted, bonus);
        System.out.println("Your final score was " + highScore);
        score = 10000;
        levelCompleted = 8;
        bonus = 100;


        highScore= calculateScore(gameOver, score, levelCompleted, bonus);
        System.out.println("Your final score was " + highScore);
    }

    public static int calculateScore(boolean gameOver, int score, int levelCompleted, int bonus)
        {
            if (gameOver) {
                int finalScore = score + (levelCompleted * bonus);
                finalScore += 2000;
                return finalScore;
            }
            return -1;


        }
    }

// Create a method called displayHighScorePosition
// it should a players name as a paramater, and a 2nd paramater as a position in the high score table
// you should display the player name along with a massage like "managed to get into position" and the
// and the position they got and a further massage "on the high score table "
//
// Create a second metod called calculatedHigHScorePosition
// it should be sent one argument only, the player score
// it should return an int
// The return data should be
// 1 if the score is >1000
// 2 id the score is >500 and <1000
// if the socre is  >100 and <500
// 4 in all other cases
// call both methods and display the result of the following
// a score of 1500,900,400  and 50

package com.john;

public class Main {
    public static void main(String[] args) {
        int highScorePosition = calculateScorePosition(1500);
        displayHighScorePosition("Tim", highScorePosition);

        int highScorePosition = calculateScorePosition(900);
        displayHighScorePosition("Bob", highScorePosition);

        int highScorePosition = calculateScorePosition(400);
        displayHighScorePosition("waheed", highScorePosition);

        int highScorePosition = calculateScorePosition(50);
        displayHighScorePosition("john", highScorePosition);
    }


    public static void displayHighScorePosition(String playerName, int highScorePosition) {
        System.out.println(playerName + "managed to get into position"
                + highScorePosition + "on the high score table");
    }

    public static int calculatedHigHScorePosition(int playerScore) {
//        if (playerScore > 1000) {
//            return 1;
//        } else if (playerScore > 500 && playerScore < 1000) {
//            return 2;
//        } else if (playerScore > 100 && playerScore < 500) {
//            return 3;
//        } else {
//            return 4;
//        }

        int position = 4;
        if (playerScore >= 1000){
            position = 1;
        }else if (playerScore >= 500){
            position =2 ;
        } else if (playerScore >= 100) {
            position = 3;
        }
        return position;
    }

// Project name: Method Overloading.
// There is must be sth Unique which is called Signature. return type or paramater.

/* Method overloading  Recap: is a features that allows us to have more than one method with
the same name, so long as we use diff paramaters.

it is the ability to create multiple methods of tha same name with different implementation.
calls to an oveloaded method will run a specific implementation of that method.
in the example belows we had calculateScore method with 0,1  and 2 parameter.
advantaga: it improves code readability and re-usability.
           it is easier to remember one method name instead of remembering multiple names.
           Achives consistancy in naming. one name for methods that are commonly used for example println.
           Overloaded methods give programmers the flexibality to call a similar method with different types of data.
 */
package com.john;

public class Main {

    public static void main(String[] args) {
        //private static final String INVALID_VALUE_MESSAGE = "Invalid value";
        int newScore = calculateScore("John", 500);
        System.out.println("New score is Equall to " + newScore);
        calculateScore(75);
        calculateScore();
        double centimeters = calcFeetAndInchesToCentimeters(6, 13);
        if (centimeters < 0.0) {
            System.out.println("Invalid paramaters");
        }
        calcFeetAndInchesToCentimeters(157);
        System.out.println(getDurationString(65, 45));
        System.out.println(getDurationString(3945l));// make sure you have used long


    }

    public static int calculateScore(String playerName, int score) {
        System.out.println("player " + playerName + " Scored " + score + " points ");
        return score * 1000;
    }

    public static int calculateScore(int score) {
        System.out.println("Unnamed player score" + score + " points ");
        return score * 1000;
    }

    public static int calculateScore() {
        System.out.println("No player name, no player Score.");
        return 0;
    }
    // Challenge :
    //    Create a method called calcFeetAndInchesToCentimeters
    //    It need to have two paramaters.
    //    feet is the first paramater, Inches is the 2nd paramater
    //
    //
    //    You should validate that the first paramater feet is >= 0
    //    You should validate that the 2nd paramater inches is >=0 and <=12
    //    return -1 from method if either of the above is not true
    //
    // if the paramaters are valid, then calculate how many centimeters.
    // comprise the feet and inches passed to this method and return
    // the value.

    //
    // Create a 2nd method of the same name but with only one parameter
    // inches is the paramater.
    // validate that its >=0
    // return -1 if it is not true.
    // But if it's valid , then calculate how many feet are in the inches.
    // and then here is the tricky part
    // call the other overloaded method passing the correct feet and inches.
    // calculated so that it can calculated correctly.
    // hints: use double for your number datatypes is probably a good idea.
    // i inch = 2.54cm and one foot = 12 inches.
    // use the link i give you to confirm your code is calculating correctly.
    // calling another overloaded method just requires you to use the
    // right number of paramaters.
    // right number of paramaters.
    public static double calcFeetAndInchesToCentimeters(double feet, double Inches) {
        //if((feet<0)|| ((Inches <0) && (Inches>12))){
        if ((feet < 0) || ((Inches < 0) || (Inches > 12))) {

            System.out.println("Invalid feet or inches paramater");

            return -1;
        }
        double centimeters = (feet * 12) * 2.54;
        centimeters += Inches * 2.54;
        System.out.println(feet + " feet ," + Inches + "Inches = " + centimeters + "cm");
        return centimeters;
    }

    public static double calcFeetAndInchesToCentimeters(double Inches) {
        if (Inches < 0) {
            return -1;

        }
        double feet = (int) Inches / 12;
        double remainingInches = (int) Inches % 12;
        System.out.println(Inches + "inches is equal to " + feet + "feet and" + remainingInches + "inches");
        return calcFeetAndInchesToCentimeters(feet, remainingInches);
    }

    // Seconds And Minutes Challenge.
    // you could also write private implace of public or  you can not write both of them
    private static String getDurationString(int minutes, long seconds) {
        if ((minutes < 0) || ((seconds < 0) || (seconds > 59))) {
            return "invalid value";
        }
        long hours = minutes / 60;
        long remainingMinutes = minutes % 60;

        String hoursString = hours + "h";
        if (hours < 10){
            hoursString = "0"+ hoursString;
        }

        String minutesString = remainingMinutes + "m";
        if (remainingMinutes< 10){
            minutesString = "0"+ minutesString;
        }

        String secondsString = seconds+ "s";
        if (seconds< 10){
            secondsString = "0"+ secondsString;
        }


        return hoursString+ " " + minutesString + " " + secondsString + " ";
    }

    private static String getDurationString(long seconds) {
        if (seconds < 0)
            return "Invalid value ";

    long  minutes = seconds / 60;
    long remainingSeconds = seconds % 60;
    return getDurationString((int) minutes,remainingSeconds);
}




}



// project : sample coding exercise.
public class PositiveNegativeZero {
    public static void main(String[] args) {
        CheckNumber(5);
        CheckNumber(-5);
        CheckNumber(0);
    }
    public static void CheckNumber(int number){
        if (number > 0){
            System.out.println("Positive");
        }else if(number < 0){
            System.out.println("Negative");
        }else if(number == 0){
            System.out.println("zero");
        }

    }
}

//project name : switch statment and if else.
package com.john;



public class Main {

    public static void main(String[] args) {
	 int value = 3;
	 if (value == 1){
         System.out.println("Value was 1 ");
     }else if (value == 2){
         System.out.println("Value was 2");
     }else {
         System.out.println("value not 1 or 2");
     }
        /*in switch statement it is good to use break statement.
        you can use switch statement with 4 primative datatypes byte,short,int and char.
         */

     // Write more code here.

      char switchValue1 = 'C';

	  switch (switchValue1){
          case 'A':
              System.out.println("char is A");
              break;
          case 'B':
              System.out.println(" Char is B");
              break;
          case 'C': case 'D': case 'E':
              System.out.println("char is C , D , OR E");
              System.out.println("Actually it was "+switchValue1);
              break;
          default:
              System.out.println("char is not found");
              break;
      }


      String month = "JUNUARY"; // jdk can support string in switch.
        switch(month.toLowerCase()){ //or you can use toUpercase
            case "junuary":
                System.out.println("jun");
                break;
            case "febuary":
                System.out.println("feb");
                break;
            default:
                    System.out.println("Not sure ");


        }



    }
}

/*
    Diff b/w is that: if is bit complex every time test a variable but in switch  we need only to test
    swithvalue so Switch is good to use...
 */

 // project : Day of the week challenge..
 package com.john;

public class Main {

    public static void main(String[] args) {
        printDayOfTheWeek(1);
        printDayOfTheWeek(2);
        printDayOfTheWeek(3);
        printDayOfTheWeek(4);
        printDayOfTheWeek(5);
        printDayOfTheWeek(6);
        printDayOfTheWeek(7);
        printDayOfTheWeek(-3);


    }
	public static void printDayOfTheWeek(int day){
        // If you want to do this for if statement. this is the alternative way of switch statement.
        if (day == 0) {
            System.out.println("Sunday");
        }else if(day == 1){
            System.out.println("Monday");
        }
        else if(day == 2){
            System.out.println("Tuesday");
        }
        else if(day == 3){
            System.out.println("Wednesday");
        }
        else if(day == 4){
            System.out.println("thursday");
        }
        else if(day == 5){
            System.out.println("Friday");
        }else{
            System.out.println("Invalid day");

        }



//	    switch (day){
//            case 1:
//                System.out.println("sunday");
//                break;
//            case 2:
//                System.out.println("Monday");
//                break;
//            case 3:
//                System.out.println("tuesday");
//                break;
//            case 4:
//                System.out.println("wednesday");
//                break;
//            case 5:
//                System.out.println("thursday");
//                break;
//            case 6:
//                System.out.println("friday");
//                break;
//            case 7:
//                System.out.println("friday");
//                break;
//            default:
//                System.out.println("Invalid value");
//                break;
//        }
        }
    }


    //Project  name : Reading user input ( if the user enter a wrong number then they give a massage otherwise calculate the birthday of a person)
    package com.timbuchalka;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter your year of birth:");

        boolean hasNextInt = scanner.hasNextInt();

        if(hasNextInt) {
            int yearOfBirth = scanner.nextInt();
            scanner.nextLine(); // handle next line character (enter key)

            System.out.println("Enter your name: ");
            String name = scanner.nextLine();
            int age = 2021 - yearOfBirth;

            if(age >= 0 && age <= 100) {
                System.out.println("Your name is " + name + ", and you are " + age + " years old.");
            } else {
                System.out.println("Invalid year of birth");
            }
        } else {
            System.out.println("Unable to parse year of birth.");
        }

        scanner.close();
    }
}

// project name: Classes and Objects oop part7
package com.oop;

public class Car {
    private int doors;
    private int wheels;
    private String model;
    private String engine;
    private String colour;

    public void setModel(String model){
        String validModel = model.toLowerCase();
        if(validModel.equals("latest")|| validModel.equals("Oldest")){
            this.model = model;
        }else{
            this.model = "Unknown";
        }

    }
    public String getModel() {
        return this.model;
    }
}
// test class
package com.oop;

public class Main {

    public static void main(String[] args) {
     Car corolla = new Car();
     Car Taxi = new Car();

     corolla.setModel("latest");
     System.out.println("Model is " +corolla.getModel());
    }

}

// project name : Constructor  oop part 7

package com.oop;

public class Account {
    private String number;
    private double balance;
    private String customerName;
    private String customerEmailAddress;
    private String customerPhoneNumber;

    public Account(String number, double balance,String customerName, String customerEmailAddress, String customerPhoneNumber){
        System.out.println("Account constructor with paramater called");
        this.number=number;
        this.balance=balance;
        this.customerName=customerName;
        this.customerEmailAddress=customerEmailAddress;
        this.customerPhoneNumber= customerPhoneNumber;
    }
    public Account(){
        // calling from one constructor to another by using this keyword.
        this("3456",1.11,"John redi","johnredi@gmail.com","0345 43 4 54 54");
        System.out.println("Empty Constructor is called");
    }
    public void deposit(double depositAmount){
        this.balance += depositAmount;
        System.out.println("Deposit of " + depositAmount + " made. New balance is " + this.balance);
    }
    public void withdrawal(double withdrawalAmount){
        if(this.balance -withdrawalAmount <=0){
            System.out.println("only " +this.balance+ "  available. withdrawal not proceed" );
        }else{
            this.balance -= withdrawalAmount;
            System.out.println("withdrawal of " +withdrawalAmount+"processed. Remaining balance ="+this.balance);
        }
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public String getCustomerName() {
        return customerName;
    }

    public void setCustomerName(String customerName) {
        this.customerName = customerName;
    }

    public String getCustomerEmailAddress() {
        return customerEmailAddress;
    }

    public void setCustomerEmailAddress(String customerEmailAddress) {
        this.customerEmailAddress = customerEmailAddress;
    }

    public String getCustomerPhoneNumber() {
        return customerPhoneNumber;
    }

    public void setCustomerPhoneNumber(String customerPhoneNumber) {
        this.customerPhoneNumber = customerPhoneNumber;
    }
}

// test class
package com.oop;

public class test {

    public static void main(String[] args) {
	/*
	  create a new class for a bank account
	  create states or faild for the account number,balance,customer name,email and phone number.

      create getters and setters for each fields
      create two additional methods
      1: to allow the customer to deposit funds this should increment the balance field).
      2: to allow the customer to withdraw funds, this should deduct from the balance field,
      but not allow the withdrawal to complete if their are insufficient funds.
      you will want to create various code in the test calss ( the one created be intellij) to
      confirm your code is working.
      add some system.out.println's in the methods above as well.
	 */
        Account johnAccount = new Account();//("1234",0.00,"John smith","john@gmail.com","0345 43 54 54");
        System.out.println(johnAccount.getNumber());
        System.out.println(johnAccount.getBalance());
//     we don't need that when we create constructor.
//        johnAccount.setNumber("1234");
//        johnAccount.setBalance(0.00);
//        johnAccount.setCustomerName("John redi");
//        johnAccount.setCustomerEmailAddress("John@gmail.com");
//        johnAccount.setCustomerPhoneNumber("03 454 345 544");
        System.out.println("current balance is"+johnAccount.getBalance());
        johnAccount.withdrawal(100.0);
        johnAccount.deposit(50.0);
        johnAccount .withdrawal(100.0);
    }

}

// Project name : Constructor challenge
package com.oop;
/*
create a new class vip customer
it should have 3 failds name,credit limit, and email address
create 3 constructor
1st constructor empty should call the constructor with 3 paramaters with default values
2nd constructor should pass on the 2 values it recives and add a default value for the 3rd
3rd constructor should save all failds
create getters only for this using code generation of intellij as setters wont be needed
test and confirm it works
 */
public class VipCustomer {
    private String name;
    private double creditLimits;
    private String emailAddress;

    public VipCustomer() {
        // we are calling to third constructor
        this("default name",50000.00,"default@gmail.com");
    }
    public VipCustomer(String name, double creditLimits) {
        this(name,creditLimits,"unknown@gmail.com");
        this.name = name;
        this.creditLimits = creditLimits;
    }
    public VipCustomer(String name, double creditLimits, String emailAddress) {
        this.name = name;
        this.creditLimits = creditLimits;
        this.emailAddress = emailAddress;
    }

    public String getName() {
        return name;
    }

    public double getCreditLimits() {
        return creditLimits;
    }

    public String getEmailAddress() {
        return emailAddress;
    }
}
// test class
package com.oop;


public class Main {

    public static void main(String[] args) {
        VipCustomer customer1 = new VipCustomer();
        System.out.println(customer1.getName());

        VipCustomer customer2 = new VipCustomer("John",25000.00);
        System.out.println(customer2.getName());

        VipCustomer customer3 = new VipCustomer("redi",100.00,"redi@gmail.com");
        System.out.println(customer3.getName());
        System.out.println(customer3.getCreditLimits());

    }
}

// Project name : part 8 ARRAY
package com.oop;

public class Main {

    public static void main(String[] args) {
    /*Array Declaration
	int [] myIntArray =;
	myIntArray =  new int[10];  long way*/
     //int [] myIntArray = new int[10];//Easy way to declare
      //  myIntArray[5] = 50;   // saving value
//     double[] myDoubleArray = new double [10];// double array
//       // System.out.println(myIntArray[5]);
//        int [] myIntArray = {1,2,3,4,5,6,7,8,9,10}; // best way to initilize value to array
//      //  myIntArray[0] = 45;// tedious way of initilizing and also time consuming
//       // myIntArray[1] = 50;
//       // myIntArray[2] = 68;
//        System.out.println(myIntArray[0]);
//        System.out.println(myIntArray[5]);
//        System.out.println(myIntArray[6]);
        // Another way of initializing value.
        int [] myIntArray = new int[30];
        for(int i=0; i< myIntArray.length; i++){ //you can use i<30 better to use lenght
            myIntArray[i] = i*10;
        }
        printArray(myIntArray);// only pass the name of method don't need to write square brackets.
    }
    // print array by using function .
    public static void printArray(int[] array){
        for (int i=0; i< array.length; i++){
            System.out.println("Element " + i + ", value is "+ array[i]);

        }
    }
}

// program takes 5 number from the user and print the average by using array
// program to takes 5 number from the user show index no and also find the average of this 5 numbers.


package practiceS2;


import java.util.Scanner;

public class Application {
    // for tacking input
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {

        int [] myIntegers =getIntegers(5);
        for (int i = 0; i< myIntegers.length; i++){
            System.out.println("Element "+ i +" typed values was  " + myIntegers[i]);
        }
        System.out.println("The average is  " + getAverage(myIntegers) );
    }




    public static int[] getIntegers(int numbers){
        System.out.println("Enter " + numbers + " Integer values \r");
        int [] values = new int [numbers];

        for (int i = 0; i< values.length; i++){
            values [i] = scanner.nextInt();// override
        }
        return  values;
    }



    public static double getAverage(int [] array){
        int sum = 0;
        for(int i=0; i< array.length; i++){
            sum+= array[i];
        }
        return  (double) sum/ (double)array.length;
    }
}



//project : ArrayChallenge
package com.timbuchalka;

import java.util.Arrays;
import java.util.Scanner;

public class Main {
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
	    // Create a program using arrays that sorts a list of integers in descending order.
        // Descending order is highest value to lowest.
        // In other words if the array had the values in it 106, 26, 81, 5, 15 your program should
        // ultimately have an array with 106,81,26, 15, 5 in it.
        // Set up the program so that the numbers to sort are read in from the keyboard.
        // Implement the following methods - getIntegers, printArray, and sortIntegers
        // getIntegers returns an array of entered integers from keyboard
        // printArray prints out the contents of the array
        // and sortIntegers should sort the array and return a new array containing the sorted numbers
        // you will have to figure out how to copy the array elements from the passed array into a new
        // array and sort them and return the new sorted array.

        int[] myIntegers = getIntegers(5);
        int[] sorted = sortIntegers(myIntegers);
        printArray(sorted);

    }

    public static int[] getIntegers(int capacity) {
        int[] array = new int[capacity];
        System.out.println("Enter " + capacity +" integer values:\r");
        for(int i=0; i<array.length; i++) {
            array[i] = scanner.nextInt();
        }
        return array;
    }

    public static void printArray(int[] array) {
        for(int i=0; i<array.length; i++) {
            System.out.println("Element " + i + " contents " + array[i]);
        }
    }

    public static int[] sortIntegers(int[] array) {
//        int[] sortedArray = new int[array.length];
//        for(int i=0; i<array.length; i++) {
//            sortedArray[i] = array[i];
//        }
        int[] sortedArray = Arrays.copyOf(array, array.length);

        boolean flag = true;
        int temp;
        while(flag) {
            flag = false;
            // before
            // element 0     50
            // element 1     160
            // element 2     40

             // after
            // element 0     160
            // element 1     50
            // element 2     40

            for(int i=0; i<sortedArray.length-1; i++) {
                if(sortedArray[i] < sortedArray[i + 1]) {
                    temp = sortedArray[i];
                    sortedArray[i] = sortedArray[i+1];
                    sortedArray[i+1] = temp;
                    flag = true;
                }
            }
        }

        return sortedArray;
    }


}

// Find Minumum Element among numbers
package com.timbuchalka;

import java.util.Scanner;

public class Main {

    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Enter count:");
        int count = scanner.nextInt();
        scanner.nextLine();

        int[] returnedArray = readIntegers(count);
        int returnedMin = findMin(returnedArray);

        System.out.println("min = " + returnedMin);

    }

    private static int[] readIntegers(int count) {

        int[] array = new int[count];

        for(int i = 0; i<array.length; i++) {
            System.out.println("Enter a number:");
            int number = scanner.nextInt();
            scanner.nextLine();
            array[i] = number;
        }
        return array;
    }

    private static int findMin(int[] array) {

        int min = Integer.MAX_VALUE;

        for(int i=0; i<array.length; i++) {
            int value = array[i];

            if(value < min) {
                min = value;
            }
        }

        return min;
    }
}

// Reverse Array Challenge
package com.timbuchalka;

import java.util.Arrays;

public class Main {

    public static void main(String[] args) {

        int[] array = { 1, 5, 3, 7, 11, 9, 15};

        System.out.println("Array = " + Arrays.toString(array));

        reverse(array);

        System.out.println("Reversed array = " + Arrays.toString(array));
    }

    private static void reverse(int[] array) {

        int maxIndex = array.length -1;
        int halfLength = array.length / 2;
        for(int i=0; i< halfLength; i++) {
            int temp = array[i];
            array[i] = array[maxIndex -i];
            array[maxIndex - i] = temp;
        }
    }
}





// Resize Array demo
package com.timbuchalka;

import java.util.Scanner;

public class Main {

    private static Scanner s = new Scanner(System.in);
    private static int[] baseData = new int[10];

    public static void main(String[] args) {
        System.out.println("Enter 10 integers:");
        getInput();
        printArray(baseData);
        resizeArray();
        System.out.println("Enter 12 integers:");
        getInput();
//        baseData[10] = 67;
//        baseData[11] = 34;
        printArray(baseData);

    }

    private static void getInput()
    {
        for(int i = 0; i < baseData.length; i++)
            baseData[i] = s.nextInt();
    }

    private static void printArray(int[] arr)
    {
        for(int i = 0; i < arr.length; i++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    private static void resizeArray()
    {
        int[] original = baseData;

        baseData = new int[12];
        for (int i = 0; i < original.length; i++)
            baseData[i] = original[i];
    }

}
// List and Arraylist good ex which they print a menu (which option you want to select)  think carefully.
//  GroceryList class
package practiceS2;

import java.util.ArrayList;

public class groceryList {

    private ArrayList<String> groceryList = new ArrayList<String>();

    public void addGroceryItem(String item) {
        groceryList.add(item);
    }

    public void printGroceryList() {
        System.out.println("You have " + groceryList.size() + " items in your grocery list");
        for(int i=0; i< groceryList.size(); i++) {
            System.out.println((i+1) + ". " + groceryList.get(i));
        }
    }

    public void modifyGroceryItem(int position, String newItem) {
        groceryList.set(position, newItem);
        System.out.println("Grocery item " + (position+1) + " has been modified.");
    }

    public void removeGroceryItem(int position) {
        String theItem = groceryList.get(position);
        groceryList.remove(position);
    }

    public String findItem(String searchItem) {
//        boolean exists = groceryList.contains(searchItem);

        int position = groceryList.indexOf(searchItem);
        if(position >=0) {
            return groceryList.get(position);
        }

        return null;
    }

}

// Test class (read it carefully)
package practiceS2;

import java.util.Scanner;

public class Application {
    private static Scanner scanner = new Scanner(System.in);
    private static groceryList groceryList = new groceryList();
    public static void main(String[] args ) {
        boolean quit = false;
        int choice = 0;
        printInstructions();
        while(!quit) {         // .this mean the condition is true.
            System.out.println("Enter your choice: " );
            choice = scanner.nextInt();
            scanner.nextLine();

            switch(choice) {
                case 0:
                    printInstructions();
                    break;
                case 1:
                    groceryList.printGroceryList();
                    break;
                case 2:
                    addItem();
                    break;
                case 3:
                    modifyItem();
                    break;
                case 4:
                    removeItem();
                    break;
                case 5:
                    searchForItem();
                    break;
                case 6:
                    quit = true;
                    break;
            }
        }
    }





    public static void printInstructions() {
        System.out.println("\nPress ");
        System.out.println("\t 0 - To print choice options.");
        System.out.println("\t 1 - To print the list of grocery items.");
        System.out.println("\t 2 - To add an item to the list.");
        System.out.println("\t 3 - To modify an item in the list.");
        System.out.println("\t 4 - To remove an item from the list.");
        System.out.println("\t 5 - To search for an item in the list.");
        System.out.println("\t 6 - To quit the application.");
    }

    public static void addItem() {
        System.out.print("Please enter the grocery item: ");
        groceryList.addGroceryItem(scanner.nextLine());
    }

    public static void modifyItem() {
        System.out.print("Enter item number: ");
        int itemNo = scanner.nextInt();
        scanner.nextLine();
        System.out.print("Enter replacement item: ");
        String newItem = scanner.nextLine();
        groceryList.modifyGroceryItem(itemNo-1, newItem);
    }

    public static void removeItem() {
        System.out.print("Enter item number: ");
        int itemNo = scanner.nextInt();
        scanner.nextLine();
        groceryList.removeGroceryItem(itemNo-1);

    }

    public static void searchForItem() {
        System.out.print("Item to search for: ");
        String searchItem = scanner.nextLine();
        if(groceryList.findItem(searchItem) != null) {
            System.out.println("Found " + searchItem + " in  our grocery list");
        } else {
            System.out.println(searchItem + " is not in the shopping list");
        }

    }

}

  Output of the program

    press
	 0 - To print choice option.
	 1 - To print the list of the grocery item .
	 2 - To add an item to the list.
	 3 - To modify and item to the list.
	 4 - To remove an item from the list.
	 5 - To search an item in the list.
	 6 - To quit an applicaion .
Enter your choice:
2
Please enter the grocery item:
milk
Enter your choice:
2
Please enter the grocery item:
panne
Enter your choice:
2
Please enter the grocery item:
morabba
Enter your choice:
3
Enter item number:
2
Enter replacement item:
chakny
Grocery item 2has been modified.
Enter your choice:
1
You hava 3items in your grocery list
1.milk
2.chakny
3.morabba
Enter your choice:
5
Item to search for:
been
beenis not in the shopping list
Enter your choice:
5
Item to search for:
chakny
Foundchakny in our grocery List
Enter your choice:
4
Enter Item number
2
Enter your choice:
1
You hava 2items in your grocery list
1.milk
2.morabba
Enter your choice:




// same as privious program but there is some addition Some Addition in above program     for correctiong your concept.
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 23/08/15.
 */
public class GroceryList {
    private ArrayList<String> groceryList = new ArrayList<String>();

    public void addGroceryItem(String item) {

        groceryList.add(item);
    }


    public ArrayList<String> getGroceryList() {
        return groceryList;
    }

    public void printGroceryList() {
        System.out.println("You have " + groceryList.size() + " items in your grocery list");
        for(int i=0; i< groceryList.size(); i++) {
            System.out.println((i+1) + ". " + groceryList.get(i));
        }
    }

    public void modifyGroceryItem(String currentItem, String newItem) {
        int position = findItem(currentItem);
        if(position >= 0) {
            modifyGroceryItem(position, newItem);
        }

    }
    //------
    private void modifyGroceryItem(int position, String newItem) {
        groceryList.set(position, newItem);
        System.out.println("Grocery item " + (position+1) + " has been modified.");
    }
 // ---- think about it
    public void removeGroceryItem(String item) {
        int position = findItem(item);
        if(position >= 0) {
            removeGroceryItem(position);
        }
    }
    private void removeGroceryItem(int position) {
        groceryList.remove(position);
    }

    private int findItem(String searchItem) {
        return groceryList.indexOf(searchItem);
    }

    public boolean onFile(String searchItem) {
        int position = findItem(searchItem);
        if(position >=0) {
            return true;
        }

        return false;
    }
}

// Test classs
package com.timbuchalka;

import java.util.ArrayList;
import java.util.Scanner;

public class Main {

    private static Scanner scanner = new Scanner(System.in);
    private static GroceryList groceryList = new GroceryList();

    public static void main(String[] args) {
        boolean quit = false;
        int choice = 0;

        printInstructions();
        while (!quit) {
            System.out.println("Enter your choice: ");
            choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 0:
                    printInstructions();
                    break;
                case 1:
                    groceryList.printGroceryList();
                    break;
                case 2:
                    addItem();
                    break;
                case 3:
                    modifyItem();
                    break;
                case 4:
                    removeItem();
                    break;
                case 5:
                    searchForItem();
                    break;
                case 6:
                    processArrayList();
                case 7:
                    quit = true;
                    break;
            }
        }
    }

    public static void printInstructions() {
        System.out.println("\nPress ");
        System.out.println("\t 0 - To print choice options.");
        System.out.println("\t 1 - To print the list of grocery items.");
        System.out.println("\t 2 - To add an item to the list.");
        System.out.println("\t 3 - To modify an item in the list.");
        System.out.println("\t 4 - To remove an item from the list.");
        System.out.println("\t 5 - To search for an item in the list.");
        System.out.println("\t 6 - To quit the application.");
    }

    public static void addItem() {
        System.out.print("Please enter the grocery item: ");
        groceryList.addGroceryItem(scanner.nextLine());
    }

    public static void modifyItem() {
        System.out.print("Current item name: ");
        String itemNo = scanner.nextLine();
        System.out.print("Enter new item: ");
        String newItem = scanner.nextLine();
        groceryList.modifyGroceryItem(itemNo, newItem);
    }

    public static void removeItem() {
        System.out.print("Enter item name: ");
        String itemNo = scanner.nextLine();
        groceryList.removeGroceryItem(itemNo);
    }

    public static void searchForItem() {
        System.out.print("Item to search for: ");
        String searchItem = scanner.nextLine();
        if(groceryList.onFile(searchItem)) {
            System.out.println("Found " + searchItem);
        } else {
            System.out.println(searchItem + ", not on file.");
        }
    }

    public static void processArrayList() {
        ArrayList<String> newArray = new ArrayList<String>();
        newArray.addAll(groceryList.getGroceryList());

        ArrayList<String> nextArray = new ArrayList<String>(groceryList.getGroceryList());

        String[] myArray = new String[groceryList.getGroceryList().size()];
        myArray = groceryList.getGroceryList().toArray(myArray);


    }

}

//Arraylist Challenge

	    // Create a program that implements a simple mobile phone with the following capabilities.
        // Able to store, modify, remove and query contact names.
        // You will want to create a separate class for Contacts (name and phone number).
        // Create a master class (MobilePhone) that holds the ArrayList of Contacts
        // The MobilePhone class has the functionality listed above.
        // Add a menu of options that are available.
        // Options:  Quit, print list of contacts, add new contact, update existing contact, remove contact
        // and search/find contact.
        // When adding or updating be sure to check if the contact already exists (use name)
        // Be sure not to expose the inner workings of the Arraylist to MobilePhone
        // e.g. no ints, no .get(i) etc
        // MobilePhone should do everything with Contact objects only.

package com.timbuchalka;

/**
 * Created by dev on 28/08/15.
 */
public class Contact {
    private String name;
    private String phoneNumber;

    public Contact(String name, String phoneNumber) {
        this.name = name;
        this.phoneNumber = phoneNumber;
    }

    public String getName() {
        return name;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public static Contact createContact(String name, String phoneNumber) {
        return new Contact(name, phoneNumber);
    }
}

//Mobile phone class
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 28/08/15.
 * Revised by Tim on 4th Feb 2018.
 */
public class MobilePhone {
    private String myNumber;
    private ArrayList<Contact> myContacts;

    public MobilePhone(String myNumber) {
        this.myNumber = myNumber;
        this.myContacts = new ArrayList<Contact>();
    }

    public boolean addNewContact(Contact contact) {
        if(findContact(contact.getName()) >=0) {
            System.out.println("Contact is already on file");
            return false;
        }

        myContacts.add(contact);
        return true;

    }

    public boolean updateContact(Contact oldContact, Contact newContact) {
        int foundPosition = findContact(oldContact);
        if(foundPosition <0) {
            System.out.println(oldContact.getName() +", was not found.");
            return false;
        } else if(findContact(newContact.getName()) != -1) {
            System.out.println("Contact with name " + newContact.getName() +
                " already exists.  Update was not successful.");
            return false;
        }

        this.myContacts.set(foundPosition, newContact);
        System.out.println(oldContact.getName() + ", was replaced with " + newContact.getName());
        return true;
    }

    public boolean removeContact(Contact contact) {
        int foundPosition = findContact(contact);
        if(foundPosition <0) {
            System.out.println(contact.getName() +", was not found.");
            return false;
        }
        this.myContacts.remove(foundPosition);
        System.out.println(contact.getName() + ", was deleted.");
        return true;
    }

    private int findContact(Contact contact) {
        return this.myContacts.indexOf(contact);
    }

    private int findContact(String contactName) {
        for(int i=0; i<this.myContacts.size(); i++) {
            Contact contact = this.myContacts.get(i);
            if(contact.getName().equals(contactName)) {
                return i;
            }
        }
        return -1;
    }

    public String queryContact(Contact contact) {
        if(findContact(contact) >=0) {
            return contact.getName();
        }
        return null;
    }

    public Contact queryContact(String name) {
        int position = findContact(name);
        if(position >=0) {
            return this.myContacts.get(position);
        }

        return null;
    }

    public void printContacts() {
        System.out.println("Contact List");
        for(int i=0; i<this.myContacts.size(); i++) {
            System.out.println((i+1) + "." +
                        this.myContacts.get(i).getName() + " -> " +
                        this.myContacts.get(i).getPhoneNumber());
        }

    }
}

// Main and Test class
package com.timbuchalka;

import java.util.Scanner;

public class Main {
    private static Scanner scanner = new Scanner(System.in);
    private static MobilePhone mobilePhone = new MobilePhone("0039 330 4404");

    public static void main(String[] args) {

        boolean quit = false;
        startPhone();
        printActions();
        while(!quit) {
            System.out.println("\nEnter action: (6 to show available actions)");
            int action = scanner.nextInt();
            scanner.nextLine();

            switch (action) {
                case 0:
                    System.out.println("\nShutting down...");
                    quit = true;
                    break;

                case 1:
                    mobilePhone.printContacts();
                    break;

                case 2:
                    addNewContact();
                    break;

                case 3:
                    updateContact();
                    break;

                case 4:
                    removeContact();
                    break;

                case 5:
                    queryContact();
                    break;

                case 6:
                    printActions();
                    break;
            }

        }

    }

    private static void addNewContact() {
        System.out.println("Enter new contact name: ");
        String name = scanner.nextLine();
        System.out.println("Enter phone number: ");
        String phone = scanner.nextLine();
        Contact newContact = Contact.createContact(name, phone);
        if(mobilePhone.addNewContact(newContact)) {
            System.out.println("New contact added: name = " + name + ", phone = "+ phone);
        } else {
            System.out.println("Cannot add, " + name + " already on file");
        }
    }

    private static void updateContact() {
        System.out.println("Enter existing contact name: ");
        String name = scanner.nextLine();
        Contact existingContactRecord = mobilePhone.queryContact(name);
        if(existingContactRecord == null) {
            System.out.println("Contact not found.");
            return;
        }

        System.out.print("Enter new contact name: ");
        String newName = scanner.nextLine();
        System.out.print("Enter new contact phone number: ");
        String newNumber = scanner.nextLine();
        Contact newContact = Contact.createContact(newName, newNumber);
        if(mobilePhone.updateContact(existingContactRecord, newContact)) {
            System.out.println("Successfully updated record");
        } else {
            System.out.println("Error updating record.");
        }
    }

    private static void removeContact() {
        System.out.println("Enter existing contact name: ");
        String name = scanner.nextLine();
        Contact existingContactRecord = mobilePhone.queryContact(name);
        if (existingContactRecord == null) {
            System.out.println("Contact not found.");
            return;
        }

        if(mobilePhone.removeContact(existingContactRecord)) {
            System.out.println("Successfully deleted");
        } else {
            System.out.println("Error deleting contact");
        }
    }

    private static void queryContact() {
        System.out.println("Enter existing contact name: ");
        String name = scanner.nextLine();
        Contact existingContactRecord = mobilePhone.queryContact(name);
        if (existingContactRecord == null) {
            System.out.println("Contact not found.");
            return;
        }

        System.out.println("Name: " + existingContactRecord.getName() + " phone number is " + existingContactRecord.getPhoneNumber());
    }

    private static void startPhone() {
        System.out.println("Starting phone...");
    }

    private static void printActions() {
        System.out.println("\nAvailable actions:\npress");
        System.out.println("0  - to shutdown\n" +
                           "1  - to print contacts\n" +
                           "2  - to add a new contact\n" +
                           "3  - to update  an existing contact\n" +
                           "4  - to remove an existing contact\n" +
                           "5  - query if an existing contact exists\n" +
                           "6  - to print a list of available actions.");
        System.out.println("Choose your action: ");
    }

}


// Wrapper classes ( Autoboxing and unboxing).

package com.timbuchalka;

import java.util.ArrayList;

class IntClass {
    private int myValue;

    public IntClass(int myValue) {
        this.myValue = myValue;
    }

    public int getMyValue() {
        return myValue;
    }

    public void setMyValue(int myValue) {
        this.myValue = myValue;
    }
}


public class Main {

    public static void main(String[] args) {
        // overview of array and arralist
	    String[] strArray = new String[10];
        int[] intArray = new int[10];
        // we can create arrylist of String keyword b/c String is a class
        ArrayList<String> strArrayList = new ArrayList<String>();
        strArrayList.add("Tim");
        // But we can't create Arraylist of int b/c it's a type and wrapper class of int is Integer ( you can seach out about this.)
//        ArrayList<int> intArrayList = new ArrayList<int>();

//        we make arraylist of IntClass b/c we create class of this then we create arraylist otherwise you can't.
        ArrayList<IntClass> intClassArrayList = new ArrayList<IntClass>();

        // Integer is a class you can see in below example.
        intClassArrayList.add(new IntClass(54));
        Integer integer = new Integer(54);
        Double doubleValue = new Double(12.25);

        ArrayList<Integer> intArrayList = new ArrayList<Integer>();
//        for(int i=0; i<=10; i++) {
//            intArrayList.add(Integer.valueOf(i));
//        }
//
//        for(int i=0; i<=10; i++) {
//            System.out.println(i + " --> " + intArrayList.get(i).intValue());
//        }

        Integer myIntValue = 56; // Integer.valueOf(56);
        int myInt = myIntValue.intValue(); // myIntValue.intValue();

        ArrayList<Double> myDoubleValues = new ArrayList<Double>();
        for(double dbl=0.0; dbl<=10.0; dbl += 0.5) {
            myDoubleValues.add(dbl);
        }

        for(int i=0; i<myDoubleValues.size(); i++) {
            double value = myDoubleValues.get(i);
            System.out.println(i + "  --> " + value);
        }




    }
}

// Autoboxing and Unboxing challenge


 // You job is to create a simple banking application.
        // There should be a Bank class
        // It should have an arraylist of Branches
        // Each Branch should have an arraylist of Customers
        // The Customer class should have an arraylist of Doubles (transactions)
        // Customer:
        // Name, and the ArrayList of doubles.
        // Branch:
        // Need to be able to add a new customer and initial transaction amount.
        // Also needs to add additional transactions for that customer/branch
        // Bank:
        // Add a new branch
        // Add a customer to that branch with initial transaction
        // Add a transaction for an existing customer for that branch
        // Show a list of customers for a particular branch and optionally a list
        // of their transactions
        // Demonstration autoboxing and unboxing in your code
        // Hint: Transactions
        // Add data validation.
        // e.g. check if exists, or does not exist, etc.
        // Think about where you are adding the code to perform certain actions
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 4/09/15.
 */
public class Bank {
    private String name;
    private ArrayList<Branch> branches;

    public Bank(String name) {
        this.name = name;
        this.branches = new ArrayList<Branch>();
    }

    public boolean addBranch(String branchName) {
        if(findBranch(branchName) == null) {
            this.branches.add(new Branch(branchName));
            return true;
        }

        return false;
    }

    public boolean addCustomer(String branchName, String customerName, double initialAmount) {
        Branch branch = findBranch(branchName);
        if(branch != null) {
            return branch.newCustomer(customerName, initialAmount);
        }

        return false;
    }

    public boolean addCustomerTransaction(String branchName, String customerName, double amount) {
        Branch branch = findBranch(branchName);
        if(branch != null) {
            return branch.addCustomerTransaction(customerName, amount);
        }

        return false;
    }

    private Branch findBranch(String branchName) {
        for(int i=0; i<this.branches.size(); i++) {
            Branch checkedBranch = this.branches.get(i);
            if(checkedBranch.getName().equals(branchName)) {
                return checkedBranch;
            }
        }

        return null;
    }

   public boolean listCustomers(String branchName, boolean showTransactions) {
       Branch branch = findBranch(branchName);
       if(branch != null) {
           System.out.println("Customer details for branch " + branch.getName());

           ArrayList<Customer> branchCustomers = branch.getCustomers();
           for(int i=0; i<branchCustomers.size(); i++) {
               Customer branchCustomer = branchCustomers.get(i);
               System.out.println("Customer: " + branchCustomer.getName() + "[" + (i+1) + "]");
               if(showTransactions) {
                   System.out.println("Transactions");
                   ArrayList<Double> transactions = branchCustomer.getTransactions();
                   for(int j=0; j<transactions.size(); j++) {
                       System.out.println("[" + (j+1) + "]  Amount "  + transactions.get(j));
                   }
               }
           }
           return true;
       } else {
           return false;
       }
   }


}

// Branch class
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 4/09/15.
 */
public class Branch {
    private String name;
    private ArrayList<Customer> customers;

    public Branch(String name) {
        this.name = name;
        this.customers = new ArrayList<Customer>();
    }

    public String getName() {
        return name;
    }

    public ArrayList<Customer> getCustomers() {
        return customers;
    }

    public boolean newCustomer(String customerName, double initialAmount) {
        if(findCustomer(customerName) == null) {
            this.customers.add(new Customer(customerName, initialAmount));
            return true;
        }

        return false;
    }

    public boolean addCustomerTransaction(String customerName, double amount) {
        Customer existingCustomer = findCustomer(customerName);
        if(existingCustomer != null) {
            existingCustomer.addTransaction(amount);
            return true;
        }

        return false;
    }

    private Customer findCustomer(String customerName) {
        for(int i=0; i<this.customers.size(); i++) {
            Customer checkedCustomer = this.customers.get(i);
            if(checkedCustomer.getName().equals(customerName)) {
                return checkedCustomer;
            }
        }

        return null;
    }
}

// Custome class
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 4/09/15.
 */
public class Customer {
    private String name;
    private ArrayList<Double> transactions;

    public Customer(String name, double initialAmount) {
        this.name = name;
        this.transactions = new ArrayList<Double>();
        addTransaction(initialAmount);
    }

    public void addTransaction(double amount) {
        this.transactions.add(amount);
    }

    public String getName() {
        return name;
    }

    public ArrayList<Double> getTransactions() {
        return transactions;
    }
}

// Test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {


        Bank bank = new Bank("National Australia Bank");

        if(bank.addBranch("Adelaide")) {
            System.out.println("Adelaide branch created");
        }

        bank.addCustomer("Adelaide", "Tim", 50.05);
        bank.addCustomer("Adelaide", "Mike", 175.34);
        bank.addCustomer("Adelaide", "Percy", 220.12);

        bank.addBranch("Sydney");
        bank.addCustomer("Sydney", "Bob", 150.54);

        bank.addCustomerTransaction("Adelaide", "Tim", 44.22);
        bank.addCustomerTransaction("Adelaide", "Tim", 12.44);
        bank.addCustomerTransaction("Adelaide", "Mike", 1.65);

        bank.listCustomers("Adelaide", true);
        bank.listCustomers("Sydney", true);

        bank.addBranch("Melbourne");

        if(!bank.addCustomer("Melbourne", "Brian", 5.53)) {
            System.out.println("Error Melbourne branch does not exist");
        }

        if(!bank.addBranch("Adelaide")) {
            System.out.println("Adelaide branch already exists");
        }

        if(!bank.addCustomerTransaction("Adelaide", "Fergus", 52.33)) {
            System.out.println("Customer does not exist at branch");
        }

        if(!bank.addCustomer("Adelaide", "Tim", 12.21)) {
            System.out.println("Customer Tim already exists");
        }

    }
}


// lINKLIST  ( FOR MORE INFORMATION YOU CAN VISIT TO VIDE 9 PART VIDEO NUMBER 18)
package com.timbuchalka;

/**
 * Created by dev on 16/09/15.
 */
public class Customer {
    private String name;
    private double balance;

    public Customer(String name, double balance) {
        this.name = name;
        this.balance = balance;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }
}

// Demo class


package com.timbuchalka;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Scanner;

/**
 * Created by dev on 16/09/15.
 */
public class Demo {
    public static void main(String[] args) {
        LinkedList<String> placesToVisit = new LinkedList<String>();
        addInOrder(placesToVisit, "Sydney");
        addInOrder(placesToVisit, "Melbourne");
        addInOrder(placesToVisit, "Brisbane");
        addInOrder(placesToVisit, "Perth");
        addInOrder(placesToVisit, "Canberra");
        addInOrder(placesToVisit, "Adelaide");
        addInOrder(placesToVisit, "Darwin");
        printList(placesToVisit);

        addInOrder(placesToVisit, "Alice Springs");
        addInOrder(placesToVisit, "Darwin");
        printList(placesToVisit);
        visit(placesToVisit);
    }

    private static void printList(LinkedList<String> linkedList) {
        Iterator<String> i= linkedList.iterator();
        while(i.hasNext()) {
            System.out.println("Now visiting " + i.next());
        }
        System.out.println("=========================");
    }

    private static boolean addInOrder(LinkedList<String> linkedList, String newCity) {
        ListIterator<String> stringListIterator = linkedList.listIterator();

        while(stringListIterator.hasNext()) {
            int comparison = stringListIterator.next().compareTo(newCity);
            if(comparison == 0) {
                // equal, do not add
                System.out.println(newCity + " is already included as a destination");
                return false;
            } else if(comparison > 0) {
                // new City should appear before this one
                // Brisbane  -> Adelaide
                stringListIterator.previous();
                stringListIterator.add(newCity);
                return true;
            } else if(comparison < 0) {
                // move on next city
            }
        }

        stringListIterator.add(newCity);
        return true;
    }

    private static void visit(LinkedList cities) {
        Scanner scanner = new Scanner(System.in);
        boolean quit = false;
        boolean goingForward = true;
        ListIterator<String> listIterator = cities.listIterator();

        if(cities.isEmpty()) {
            System.out.println("No cities in the itenerary");
            return;
        } else {
            System.out.println("Now visiting " + listIterator.next());
            printMenu();
        }

        while (!quit) {
            int action = scanner.nextInt();
            scanner.nextLine();
            switch(action) {
                case 0:
                    System.out.println("Holiday (Vacation) over");
                    quit = true;
                    break;

                case 1:
                    if(!goingForward) {
                        if(listIterator.hasNext()) {
                            listIterator.next();
                        }
                        goingForward = true;
                    }
                    if(listIterator.hasNext()) {
                        System.out.println("Now visiting " + listIterator.next());
                    } else {
                        System.out.println("Reached the end of the list");
                        goingForward = false;
                    }
                    break;

                case 2:
                    if(goingForward) {
                        if(listIterator.hasPrevious()) {
                            listIterator.previous();
                        }
                        goingForward = false;
                    }
                    if(listIterator.hasPrevious()) {
                        System.out.println("Now visiting " + listIterator.previous());
                    } else {
                        System.out.println("We are at the start of the list");
                        goingForward = true;
                    }
                    break;

                case 3:
                    printMenu();
                    break;

            }

        }
    }

    private static void printMenu() {
        System.out.println("Available actions:\npress ");
        System.out.println("0 - to quit\n" +
                "1 - go to next city\n" +
                "2 - go to previous city\n" +
                "3 - print menu options");
    }



}


// main class
package com.timbuchalka;

import java.util.ArrayList;

public class Main {

    public static void main(String[] args) {
	    Customer customer = new Customer("Tim", 54.96);
        Customer anotherCustomer;
        anotherCustomer = customer;
        anotherCustomer.setBalance(12.18);
        System.out.println("Balance for customer " + customer.getName() + " is " + customer.getBalance());

        ArrayList<Integer> intList = new ArrayList<Integer>();

        intList.add(1);
        intList.add(3);
        intList.add(4);

        for(int i=0; i<intList.size(); i++) {
            System.out.println(i +": " + intList.get(i));
        }

        intList.add(1, 2);

        for(int i=0; i<intList.size(); i++) {
            System.out.println(i +": " + intList.get(i));
        }

    }
}



// Link list challenge

// Song class

package com.timbuchalka;

/**
 * Created by dev on 18/09/15.
 */
public class Song {
    private String title;
    private double duration;

    public Song(String title, double duration) {
        this.title = title;
        this.duration = duration;
    }

    public String getTitle() {
        return title;
    }

    @Override
    public String toString() {
        return this.title + ": " + this.duration;
    }
}


// Album class
package com.timbuchalka;

import java.util.ArrayList;
import java.util.LinkedList;

/**
 * Created by dev on 18/09/15.
 */
public class Album {
    private String name;
    private String artist;
    private ArrayList<Song> songs;

    public Album(String name, String artist) {
        this.name = name;
        this.artist = artist;
        this.songs = new ArrayList<Song>();
    }

    public boolean addSong(String title, double duration) {
        if(findSong(title) == null) {
            this.songs.add(new Song(title, duration));
            return true;
        }
        return false;
    }

    private Song findSong(String title) {
        for(Song checkedSong: this.songs) {
            if(checkedSong.getTitle().equals(title)) {
                return checkedSong;
            }
        }
        return null;
    }

    public boolean addToPlayList(int trackNumber, LinkedList<Song> playList) {
        int index = trackNumber -1;
        if((index >0) && (index <= this.songs.size())) {
            playList.add(this.songs.get(index));
            return true;
        }
        System.out.println("This album does not have a track " + trackNumber);
        return false;
    }

    public boolean addToPlayList(String title, LinkedList<Song> playList) {
        Song checkedSong = findSong(title);
        if(checkedSong != null) {
            playList.add(checkedSong);
            return true;
        }
        System.out.println("The song " + title + " is not in this album");
        return false;
    }

}

// Test class
package com.timbuchalka;

import java.util.*;

public class Main {

    private static ArrayList<Album> albums = new ArrayList<Album>();

    public static void main(String[] args) {
	    // Create a program that implements a playlist for songs
        // Create a Song class having Title and Duration for a song.
        // The program will have an Album class containing a list of songs.
        // The albums will be stored in an ArrayList
        // Songs from different albums can be added to the playlist and will appear in the list in the order
        // they are added.
        // Once the songs have been added to the playlist, create a menu of options to:-
        // Quit,Skip forward to the next song, skip backwards to a previous song.  Replay the current song.
        // List the songs in the playlist
        // A song must exist in an album before it can be added to the playlist (so you can only play songs that
        // you own).
        // Hint:  To replay a song, consider what happened when we went back and forth from a city before we
        // started tracking the direction we were going.
        // As an optional extra, provide an option to remove the current song from the playlist
        // (hint: listiterator.remove()

        Album album = new Album("Stormbringer", "Deep Purple");
        album.addSong("Stormbringer", 4.6);
        album.addSong("Love don't mean a thing", 4.22);
        album.addSong("Holy man", 4.3);
        album.addSong("Hold on", 5.6);
        album.addSong("Lady double dealer", 3.21);
        album.addSong("You can't do it right", 6.23);
        album.addSong("High ball shooter", 4.27);
        album.addSong("The gypsy", 4.2);
        album.addSong("Soldier of fortune", 3.13);
        albums.add(album);

        album = new Album("For those about to rock", "AC/DC");
        album.addSong("For those about to rock", 5.44);
        album.addSong("I put the finger on you", 3.25);
        album.addSong("Lets go", 3.45);
        album.addSong("Inject the venom", 3.33);
        album.addSong("Snowballed", 4.51);
        album.addSong("Evil walks", 3.45);
        album.addSong("C.O.D.", 5.25);
        album.addSong("Breaking the rules", 5.32);
        album.addSong("Night of the long knives", 5.12);
        albums.add(album);

        LinkedList<Song> playList = new LinkedList<Song>();
        albums.get(0).addToPlayList("You can't do it right", playList);
        albums.get(0).addToPlayList("Holy man", playList);
        albums.get(0).addToPlayList("Speed king", playList);  // Does not exist
        albums.get(0).addToPlayList(9, playList);
        albums.get(1).addToPlayList(8, playList);
        albums.get(1).addToPlayList(3, playList);
        albums.get(1).addToPlayList(2, playList);
        albums.get(1).addToPlayList(24, playList);  // There is no track 24

        play(playList);




    }

    private static void play(LinkedList<Song> playList) {
        Scanner scanner = new Scanner(System.in);
        boolean quit = false;
        boolean forward = true;
        ListIterator<Song> listIterator = playList.listIterator();
        if(playList.size() == 0) {
            System.out.println("No songs in playlist");
            return;
        } else {
            System.out.println("Now playing " + listIterator.next().toString());
            printMenu();
        }

        while(!quit) {
            int action = scanner.nextInt();
            scanner.nextLine();

            switch(action) {
                case 0:
                    System.out.println("Playlist complete.");
                    quit = true;
                    break;
                case 1:
                    if(!forward) {
                        if(listIterator.hasNext()) {
                            listIterator.next();
                        }
                        forward = true;
                    }
                    if(listIterator.hasNext()) {
                        System.out.println("Now playing " + listIterator.next().toString());
                    } else {
                        System.out.println("We have reached the end of the playlist");
                        forward = false;
                    }
                    break;

                case 2:
                    if(forward) {
                        if(listIterator.hasPrevious()) {
                            listIterator.previous();
                        }
                        forward = false;
                    }
                    if(listIterator.hasPrevious()) {
                        System.out.println("Now playing " + listIterator.previous().toString());
                    } else {
                        System.out.println("We are at the start of the playlist");
                        forward = true;
                    }
                    break;
                case 3:
                    if(forward) {
                        if(listIterator.hasPrevious()) {
                            System.out.println("Now replaying " + listIterator.previous().toString());
                            forward = false;
                        } else {
                            System.out.println("We are at the start of the list");
                        }
                    } else {
                        if(listIterator.hasNext()) {
                            System.out.println("Now replaying " + listIterator.next().toString());
                            forward = true;
                        } else {
                            System.out.println("We have reached the end of the list");
                        }
                    }
                    break;
                case 4:
                    printList(playList);
                    break;
                case 5:
                    printMenu();
                    break;

                case 6:
                    if(playList.size() >0) {
                        listIterator.remove();
                        if(listIterator.hasNext()) {
                            System.out.println("Now playing " + listIterator.next());
                        } else if(listIterator.hasPrevious()) {
                            System.out.println("Now playing " + listIterator.previous());
                        }
                    }
                    break;

            }
        }
    }

    private static void printMenu() {
        System.out.println("Available actions:\npress");
        System.out.println("0 - to quit\n" +
                "1 - to play next song\n" +
                "2 - to play previous song\n" +
                "3 - to replay the current song\n" +
                "4 - list songs in the playlist\n" +
                "5 - print available actions.\n" +
                "6 - delete current song from playlist");

    }


    private static void printList(LinkedList<Song> playList) {
        Iterator<Song> iterator = playList.iterator();
        System.out.println("================================");
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        System.out.println("================================");
    }

}

// Inheritance part 1
// Animal class
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Animal {

    private String name;
    private int brain;
    private int body;
    private int size;
    private int weight;

    public Animal(String name, int brain, int body, int size, int weight) {
        this.name = name;
        this.brain = brain;
        this.body = body;
        this.size = size;
        this.weight = weight;
    }

    public void eat() {
        System.out.println("Animal.eat() called");

    }

    public void move(int speed) {
        System.out.println("Animal.move() called.  Animal is moving at " +speed);

    }



    public String getName() {
        return name;
    }

    public int getBrain() {
        return brain;
    }

    public int getBody() {
        return body;
    }

    public int getSize() {
        return size;
    }

    public int getWeight() {
        return weight;
    }
}

// Dog class
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Dog extends Animal {

    private int eyes;
    private int legs;
    private int tail;
    private int teeth;
    private String coat;

    public Dog(String name, int size, int weight, int eyes, int legs, int tail, int teeth, String coat) {
        super(name, 1, 1, size, weight);
        this.eyes = eyes;
        this.legs = legs;
        this.tail = tail;
        this.teeth = teeth;
        this.coat = coat;
    }

    private void chew() {
        System.out.println("Dog.chew() called");
    }

    @Override
    public void eat() {
        System.out.println("Dog.eat() called");
        chew();
        super.eat();
    }

    public void walk() {
        System.out.println("Dog.walk() called");
        super.move(5);
    }

    public void run() {
        System.out.println("Dog.run() called");
        move(10);

    }

    private void moveLegs(int speed) {
        System.out.println("Dog.moveLegs() called");
    }
    @Override
    public void move(int speed) {
        System.out.println("Dog.move() called");
        moveLegs(speed);
        super.move(speed);
    }
}
// Fish class
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Fish extends Animal {

    private int gills;
    private int eyes;
    private int fins;

    public Fish(String name, int size, int weight, int gills, int eyes, int fins) {

        super(name, 1, 1, size, weight);
        this.gills = gills;
        this.eyes = eyes;
        this.fins = fins;
    }

    private void rest() {

    }

    private void moveMuscles() {

    }

    private void moveBackFin() {

    }

    private void swim(int speed) {
        moveMuscles();
        moveBackFin();
        super.move(speed);


    }
}

// Test class

package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
	    Animal animal = new Animal("Animal", 1, 1, 5, 5);

        Dog dog = new Dog("Yorkie", 8, 20, 2, 4, 1, 20, "long silky");
//        dog.eat();
        dog.walk();
//        dog.run();

    }
}

// Inheritance Challenge part 7
   // Challenge.
        // Start with a base class of a Vehicle, then create a Car class that inherits from this base class.
        // Finally, create another class, a specific type of Car that inherits from the Car class.
        // You should be able to hand steering, changing gears, and moving (speed in other words).
        // You will want to decide where to put the appropriate state and behaviours (fields and methods).
        // As mentioned above, changing gears, increasing/decreasing speed should be included.
        // For you specific type of vehicle you will want to add something specific for that type of car.

// class vehicle
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Vehicle {
    private String name;
    private String size;

    private int currentVelocity;
    private int currentDirection;

    public Vehicle(String name, String size) {
        this.name = name;
        this.size = size;

        this.currentVelocity = 0;
        this.currentDirection = 0;
    }

    public void steer(int direction) {
        this.currentDirection += direction;
        System.out.println("Vehicle.steer(): Steering at " + currentDirection + " degrees.");
    }

    public void move(int velocity, int direction) {
        currentVelocity = velocity;
        currentDirection = direction;
        System.out.println("Vehicle.move(): Moving at  " + currentVelocity + " in direction " + currentDirection);

    }

    public String getName() {
        return name;
    }

    public String getSize() {
        return size;
    }

    public int getCurrentVelocity() {
        return currentVelocity;
    }

    public int getCurrentDirection() {
        return currentDirection;
    }

    public void stop() {
        this.currentVelocity = 0;
    }
}
// car class
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Car extends Vehicle {

    private int wheels;
    private int doors;
    private int gears;
    private boolean isManual;

    private int currentGear;

    public Car(String name, String size, int wheels, int doors, int gears, boolean isManual) {
        super(name, size);
        this.wheels = wheels;
        this.doors = doors;
        this.gears = gears;
        this.isManual = isManual;
        this.currentGear = 1;
    }

    public void changeGear(int currentGear) {
        this.currentGear = currentGear;
        System.out.println("Car.setCurrentGear(): Changed to " + this.currentGear + " gear.");
    }

    public void changeVelocity(int speed, int direction) {
        System.out.println("Car.changeVelocity() : Velocity " + speed + " direction " + direction);
        move(speed, direction);
    }

}
// type of car outlander class
package com.timbuchalka;

/**
 * Created by dev on 6/07/15.
 */
public class Outlander extends Car {
    private int roadServiceMonths;

    public Outlander(int roadServiceMonths) {
        super("Outlander", "4WD", 5, 5, 6, false);
        this.roadServiceMonths = roadServiceMonths;
    }

    public void accelerate(int rate) {

        int newVelocity = getCurrentVelocity() + rate;
        if(newVelocity ==0) {
            stop();
            changeGear(1);
        } else if(newVelocity >0 && newVelocity <=10) {
            changeGear(1);
        } else if(newVelocity >10 && newVelocity <=20) {
            changeGear(2);
        } else if(newVelocity >20 && newVelocity <=30) {
            changeGear(3);
        } else {
            changeGear(4);
        }

        if(newVelocity > 0) {
            changeVelocity(newVelocity, getCurrentDirection());
        }


    }

}
// test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {



        Outlander outlander = new Outlander(36);
        outlander.steer(45);
        outlander.accelerate(30);
        outlander.accelerate(20);
        outlander.accelerate(-42);

    }
}
// Inheritance is   IS A Relationship.
// Section 8 and part 2 of OOP Composition( is a has a Relationship)
// Vehicle class
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Vehicle {
    private String name;

    public Vehicle(String name) {
        this.name = name;
    }
}
// Car Class
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Car extends Vehicle {
    private int doors;
    private int engineCapacity;

    public Car(String name, int doors, int engineCapacity) {
        super(name);
        this.doors = doors;
        this.engineCapacity = engineCapacity;
    }
}

// Motherboard Class
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Motherboard {

    private String model;
    private String manufacturer;
    private int ramSlots;
    private int cardSlots;
    private String bios;

    public Motherboard(String model, String manufacturer, int ramSlots, int cardSlots, String bios) {
        this.model = model;
        this.manufacturer = manufacturer;
        this.ramSlots = ramSlots;
        this.cardSlots = cardSlots;
        this.bios = bios;
    }

    public void loadProgram(String programName) {
        System.out.println("Program " + programName + " is now loading...");
    }
    public String getModel() {
        return model;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public int getRamSlots() {
        return ramSlots;
    }

    public int getCardSlots() {
        return cardSlots;
    }

    public String getBios() {
        return bios;
    }
}

// Monitor Class  Resolation is a component of monitor then we create Resoulation class below.

package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Monitor {
    private String model;
    private String manufacturer;
    private int size;
    private Resolution nativeResolution;

    public Monitor(String model, String manufacturer, int size, Resolution nativeResolution) {
        this.model = model;
        this.manufacturer = manufacturer;
        this.size = size;
        this.nativeResolution = nativeResolution;
    }

    public void drawPixelAt(int x, int y, String color) {
        System.out.println("Drawing pixel at " + x + "," + y + " in colour " + color);
    }

    public String getModel() {
        return model;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public int getSize() {
        return size;
    }

    public Resolution getNativeResolution() {
        return nativeResolution;
    }
}

// Resoulation class
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Resolution {
    private int width;
    private int height;

    public Resolution(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }
}

// Case Class which have Dimension
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Case {
    private String model;
    private String manufacturer;
    private String powerSupply;
    private Dimensions dimensions;

    public Case(String model, String manufacturer, String powerSupply, Dimensions dimensions) {
        this.model = model;
        this.manufacturer = manufacturer;
        this.powerSupply = powerSupply;
        this.dimensions = dimensions;
    }

    public void pressPowerButton() {
        System.out.println("Power button pressed");
    }

    public String getModel() {
        return model;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public String getPowerSupply() {
        return powerSupply;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }
}

//Dimension Class
package com.timbuchalka;

/**
 * Created by dev on 8/3/15.
 */
public class Dimensions {
    private int width;
    private int height;
    private int depth;

    public Dimensions(int width, int height, int depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public int getDepth() {
        return depth;
    }
}

// PC Class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class PC {
    private Case theCase;
    private Monitor monitor;
    private Motherboard motherboard;

    public PC(Case theCase, Monitor monitor, Motherboard motherboard) {
        this.theCase = theCase;
        this.monitor = monitor;
        this.motherboard = motherboard;
    }

    public void powerUp() {
        theCase.pressPowerButton();
        drawLogo();
    }

    private void drawLogo() {
        // Fancy graphics
        monitor.drawPixelAt(1200, 50, "yellow");
    }
}

// Main class or test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
        Dimensions dimensions = new Dimensions(20, 20, 5);
	    Case theCase = new Case("220B", "Dell", "240", dimensions);

        Monitor theMonitor = new Monitor("27inch Beast", "Acer", 27, new Resolution(2540, 1440));

        Motherboard theMotherboard = new Motherboard("BJ-200", "Asus", 4, 6, "v2.44");

        PC thePC = new PC(theCase, theMonitor, theMotherboard);
        thePC.powerUp();

       // Composation Challenge

        // Create a single room of a house using composition.
        // Think about the things that should be included in the room.
        // Maybe physical parts of the house but furniture as well
        // Add at least one method to access an object via a getter and
        // then that objects public method as you saw in the previous video
        // then add at least one method to hide the object e.g. not using a getter
        // but to access the object used in composition within the main class
        // like you saw in this video.


// Bedroom Class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class Bedroom {
    private String name;
    private Wall wall1;
    private Wall wall2;
    private Wall wall3;
    private Wall wall4;
    private Ceiling ceiling;
    private Bed bed;
    private Lamp lamp;

    public Bedroom(String name, Wall wall1, Wall wall2, Wall wall3, Wall wall4, Ceiling ceiling, Bed bed, Lamp lamp) {
        this.name = name;
        this.wall1 = wall1;
        this.wall2 = wall2;
        this.wall3 = wall3;
        this.wall4 = wall4;
        this.ceiling = ceiling;
        this.bed = bed;
        this.lamp = lamp;
    }

    public Lamp getLamp() {
        return this.lamp;
    }

    public void makeBed() {
        System.out.println("Bedroom -> Making bed");
        bed.make();
    }
}

// Wall Class which create object instance in above class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class Wall {
    private String direction;

    public Wall(String direction) {
        this.direction = direction;
    }

    public String getDirection() {
        return direction;
    }
}

// Ceilling class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class Ceiling {
    private int height;
    private int paintedColor;

    public Ceiling(int height, int paintedColor) {
        this.height = height;
        this.paintedColor = paintedColor;
    }

    public int getHeight() {
        return height;
    }

    public int getPaintedColor() {
        return paintedColor;
    }
}

// Bed Class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class Bed {
    private String style;
    private int pillows;
    private int height;
    private int sheets;
    private int quilt;

    public Bed(String style, int pillows, int height, int sheets, int quilt) {
        this.style = style;
        this.pillows = pillows;
        this.height = height;
        this.sheets = sheets;
        this.quilt = quilt;
    }

    public void make() {
        System.out.println("Bed -> Making");
    }

    public String getStyle() {
        return style;
    }

    public int getPillows() {
        return pillows;
    }

    public int getHeight() {
        return height;
    }

    public int getSheets() {
        return sheets;
    }

    public int getQuilt() {
        return quilt;
    }
}

// Lamp Class
package com.timbuchalka;

/**
 * Created by dev on 16/07/15.
 */
public class Lamp {
    private String style;
    private boolean battery;
    private int globRating;

    public Lamp(String style, boolean battery, int globRating) {
        this.style = style;
        this.battery = battery;
        this.globRating = globRating;
    }

    public void turnOn() {
        System.out.println("Lamp -> Turning on");
    }

    public String getStyle() {
        return style;
    }

    public boolean isBattery() {
        return battery;
    }

    public int getGlobRating() {

        return globRating;
    }
}

//Main Class

public class Main {

    public static void main(String[] args) {
         Wall wall1 = new Wall("West");
        Wall wall2 = new Wall("East");
        Wall wall3 = new Wall("South");
        Wall wall4 = new Wall("North");

        Ceiling ceiling = new Ceiling(12, 55);

        Bed bed = new Bed("Modern", 4, 3, 2, 1);

        Lamp lamp = new Lamp("Classic", false, 75);

        Bedroom bedRoom = new Bedroom("Tims", wall1, wall2, wall3, wall4, ceiling,bed, lamp);
        bedRoom.makeBed();

        bedRoom.getLamp().turnOn();




    }
}

// Part 8 video 4 Encapsulation
// Program Without using Encapsulation

package com.timbuchalka;

/**
 * Created by dev on 31/07/15.
 */
public class Player {

    public String fullName;
    public int health;
    public String weapon;

    public void loseHealth(int damage) {
        this.health = this.health - damage;
        if(this.health <=0) {
            System.out.println("Player knocked out");
            // Reduce number of lives remaining for the player
        }
    }

    public int healthRemaining() {
        return this.health;
    }
}

// Enhanced Programmer Version  Program with Using Encapsulation.
package com.timbuchalka;

/**
 * Created by dev on 31/07/15.
 */
public class EnhancedPlayer {
    private String name;
    private int hitPoints = 100;
    private String weapon;

    public EnhancedPlayer(String name, int health, String weapon) {
        this.name = name;

        if(health >0 && health <= 100) {
            this.hitPoints = health;
        }

        this.weapon = weapon;
    }

    public void loseHealth(int damage) {
        this.hitPoints = this.hitPoints - damage;
        if(this.hitPoints <=0) {
            System.out.println("Player knocked out");
            // Reduce number of lives remaining for the player
        }
    }

    public int getHealth() {
        return hitPoints;
    }
}

// Main or Test Program for both above program
// for player test
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
//	    Player player = new Player();
//        player.name = "Tim";
////        player.health = 20;
//        player.weapon = "Sword";
//
//        int damage = 10;
//        player.loseHealth(damage);
//        System.out.println("Remaining health =  " + player.healthRemaining());
//
//        damage = 11;
//        player.health = 200;
//        player.loseHealth(damage);
//        System.out.println("Remaining health =  " + player.healthRemaining());

// For Enhanced player test program.
        EnhancedPlayer player = new EnhancedPlayer("Tim", 200, "Sword");
        System.out.println("Initial health is " + player.getHealth());
    }
}

//  Encapsulation Challenge
        // Create a class and demonstate proper encapsulation techniques
        // the class will be called Printer
        // It will simulate a real Computer Printer
        // It should have fields for the toner Level, number of pages printed, and
        // also whether its a duplex printer (capable of printing on both sides of the paper).
        // Add methods to fill up the toner (up to a maximum of 100%), another method to
        // simulate printing a page (which should increase the number of pages printed).
        // Decide on the scope, whether to use constructors, and anything else you think is needed.


// Printer Class
package com.timbuchalka;

/**
 * Created by dev on 31/07/15.
 */
public class Printer {
    private int tonerLevel;
    private int pagesPrinted;
    private boolean duplex;

    public Printer(int tonerLevel, boolean duplex) {
        if(tonerLevel >-1 && tonerLevel <=100) {
            this.tonerLevel = tonerLevel;
        } else {
            this.tonerLevel = -1;
        }

        this.duplex = duplex;
        this.pagesPrinted = 0;
    }

    public int addToner(int tonerAmount) {
        if(tonerAmount >0 && tonerAmount <=100) {
            if(this.tonerLevel + tonerAmount >100) {
                return -1;
            }
            this.tonerLevel += tonerAmount;
            return this.tonerLevel;
        } else {
            return -1;
        }
    }

    public int printPages(int pages) {
        int pagesToPrint = pages;
        if(this.duplex) {
            pagesToPrint = (pages / 2) + (pages % 2);
            System.out.println("Printing in duplex mode");
        }
        this.pagesPrinted += pagesToPrint;
        return pagesToPrint;
    }

    public int getPagesPrinted() {
        return pagesPrinted;
    }
}

// Test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
        Printer printer = new Printer(50, false);
        System.out.println("initial page count = " +printer.getPagesPrinted());
        int pagesPrinted = printer.printPages(4);
        System.out.println("Pages printed was " + pagesPrinted +" new total print count for printer = " +printer.getPagesPrinted());
        pagesPrinted = printer.printPages(2);
        System.out.println("Pages printed was " + pagesPrinted +" new total print count for printer = " +printer.getPagesPrinted());

    }
}

// polymorphism which have 5 classes and one mian method. by calling one method we print alot of things in console .( this is actually poly)
//package com.timbuchalka;

class Movie {
    private String name;

    public Movie(String name) {
        this.name = name;
    }

    public String plot() {
        return "No plot here";
    }

   public String getName() {
        return name;
    }
}

   class jaws extends Movie {
       public jaws(){
           super ("jaws");
       }
       public String plot(){
           return "A shark eats lots of people ";
       }
   }
class IndependenceDay extends Movie {

    public IndependenceDay() {
        super("Independence Day");
    }

    @Override
    public String plot() {
        return "Aliens attempt to take over planet earth";
    }
}

class MazeRunner extends Movie {

    public MazeRunner() {
        super("Maze Runner");
    }

    @Override
    public String plot() {
        return "Kids try and escape a maze";
    }
}

class StarWars extends Movie {
    public StarWars() {
        super("Star Wars");
    }

    @Override
    public String plot() {
        return "Imperial Forces try to take over the universe";
    }
}

class Forgetable extends Movie {
    public Forgetable() {
        super("Forgetable");
    }

    // No plot method
}


public class practice {

    public static void main(String[] args) {
	    for(int i=1; i<11; i++) {
            Movie movie = randomMovie();
            System.out.println("Movie #" + i +
                            " : " + movie.getName() + "\n" +
                            "Plot: " + movie.plot() + "\n");
        }
    }

    public static Movie randomMovie() {
        int randomNumber = (int) (Math.random() * 5) +1;
        System.out.println("Random number generated was: " + randomNumber);
        switch (randomNumber) {
            case 1:
                return new Jaws();
            case 2:
                return new IndependenceDay();
            case 3:
                return new MazeRunner();
            case 4:
                return new StarWars();
            case 5:
                return new Forgetable();

        }

        return null;
    }
}

//Polymorphism Challenge
 // We are going to go back to the car analogy.
        // Create a base class called Car
        // It should have a few fields that would be appropriate for a generice car calss.
        // engine, cylinders, wheels, etc.
        // Constructor should initialize cylinders (number of) and name, and set wheels to 4
        // and engine to true. Cylinders and names would be passed parameters.
        //
        // Create appropriate getters
        //
        // Create some methods like startEngine, accelerate, and brake
        //
        // show a message for each in the base class
        // Now create 3 sub classes for your favorite vehicles.
        // Override the appropriate methods to demonstrate polymorphism in use.
        // put all classes in the one java file (this one).
//package com.timbuchalka;

class Car {
    private boolean engine;
    private int cylinders;
    private String name;
    private int wheels;

    public Car(int cylinders, String name) {
        this.cylinders = cylinders;
        this.name = name;
        this.wheels = 4;
        this.engine = true;
    }

    public int getCylinders() {
        return cylinders;
    }

    public String getName() {
        return name;
    }

    public String startEngine() {
        return "Car -> startEngine()";
    }

    public String accelerate() {
        return "Car -> accelerate()";
    }

    public String brake() {
        return "Car -> brake()";
    }
}

class Mitsubishi extends Car {

    public Mitsubishi(int cylinders, String name) {
        super(cylinders, name);
    }

    @Override
    public String startEngine() {
        return "Mitsubishi -> startEngine()";
    }

    @Override
    public String accelerate() {
        return "Mitsubishi -> accelerate()";
    }

    @Override
    public String brake() {
        return "Mitsubishi -> brake()";
    }
}

class Holden extends Car {

    public Holden(int cylinders, String name) {
        super(cylinders, name);
    }

    @Override
    public String startEngine() {
        return getClass().getSimpleName() +  " -> startEngine()";
    }

    @Override
    public String accelerate() {
        return getClass().getSimpleName() +  " -> accelerate()";
    }

    @Override
    public String brake() {
        return getClass().getSimpleName() +  " -> brake()";
    }
}

class Ford extends Car {

    public Ford(int cylinders, String name) {
        super(cylinders, name);
    }

    @Override
    public String startEngine() {
        return "Ford -> startEngine()";
    }

    @Override
    public String accelerate() {
        return "Ford -> accelerate()";
    }

    @Override
    public String brake() {
        return "Ford -> brake()";
    }
}

public class practice {

    public static void main(String[] args) {


        Car car = new Car(8, "Base car");
        System.out.println(car.startEngine());
        System.out.println(car.accelerate());
        System.out.println(car.brake());

        Mitsubishi mitsubishi = new Mitsubishi(6, "Outlander VRX 4WD");
        System.out.println(mitsubishi.startEngine());
        System.out.println(mitsubishi.accelerate());
        System.out.println(mitsubishi.brake());

        Ford ford = new Ford(6, "Ford Falcon");
        System.out.println(ford.startEngine());
        System.out.println(ford.accelerate());
        System.out.println(ford.brake());

        Holden holden = new Holden(6, "Holden Commodore");
        System.out.println(holden.startEngine());
        System.out.println(holden.accelerate());
        System.out.println(holden.brake());
    }


}

//  Challenge of oop previuos concept (encapsulation ,polymorphism)
// The purpose of the application is to help a ficticious company called Bills Burgers to manage
		// their process of selling hamburgers.
		// Our application will help Bill to select types of burgers, some of the additional items (additions) to
		// be added to the burgers and pricing.
		// We want to create a base hamburger, but also two other types of hamburgers that are popular ones in
		// Bills store.
		// The basic hamburger should have the following items.
		// bread roll type, meat and up to 4 additional additions (things like lettuce, tomato, carrot, etc) that
		// the customer can select to be added to the burger.
		// Each one of these items gets charged an additional
		// price so you need some way to track how many items got added and to calculate the final price (base
		// burger with all the additions).
		// This burger has a base price and the additions are all seperately priced (up to 4 additions, see above).
		// Create a Hamburger class to deal with all the above.
		// The constructor should only include the roll type, meat and price, can also include name of burger or you can use setter.
		// Also create two extra varieties of Hamburgers (subclasses) to cater for
		// a) Healthy burger (on a brown rye bread roll), plus two addition items can be added.
		// The healthy burger can have 6 items (Additions) in total.
		// hint:  you probably want to process the 2 additional items in this new class (subclass of Hamburger), not the base class (Hamburger),
		// since the 2 additions are only appropriate for this new class (in other words new burger type).
		// b) Deluxe hamburger - comes with chips and drinks as additions, but no extra additions are allowed.
		// hint:  You have to find a way to automatically add these new additions at the time the deluxe burger
		// object is created, and then prevent other additions being made.
		//  All 3 classes should have a method that can be called anytime to show the base price of the hamburger
		// plus all additionals, each showing the addition name, and addition price, and a grand/final total for the
		// burger (base price + all additions)
		// For the two additional classes this may require you to be looking at the base class for pricing and then
		// adding totals to final price.

// Humberger class
package com.timbuchalka;

/**
 * Created by dev on 11/08/15.
 */
public class Hamburger {
    private String name;
    private String meat;
    private double price;
    private String breadRollType;

    private String addition1Name;
    private double addition1Price;

    private String addition2Name;
    private double addition2Price;

    private String addition3Name;
    private double addition3Price;

    private String addition4Name;
    private double addition4Price;

    public Hamburger(String name, String meat, double price, String breadRollType) {
        this.name = name;
        this.meat = meat;
        this.price = price;
        this.breadRollType = breadRollType;
    }

    public void addHamburgerAddition1(String name, double price) {
        this.addition1Name = name;
        this.addition1Price = price;
    }

    public void addHamburgerAddition2(String name, double price) {
        this.addition2Name = name;
        this.addition2Price = price;
    }
    public void addHamburgerAddition3(String name, double price) {
        this.addition3Name = name;
        this.addition3Price = price;
    }
    public void addHamburgerAddition4(String name, double price) {
        this.addition4Name = name;
        this.addition4Price = price;
    }

    public double itemizeHamburger() {
        double hamburgerPrice = this.price;
        System.out.println(this.name + " hamburger " + " on a " + this.breadRollType + " roll "
                    + "with " + this.meat + ", price is "  + this.price);
        if(this.addition1Name != null) {
            hamburgerPrice += this.addition1Price;
            System.out.println("Added " + this.addition1Name + " for an extra " + this.addition1Price);
        }
        if(this.addition2Name != null) {
            hamburgerPrice += this.addition2Price;
            System.out.println("Added " + this.addition2Name + " for an extra " + this.addition2Price);
        }
        if(this.addition3Name != null) {
            hamburgerPrice += this.addition3Price;
            System.out.println("Added " + this.addition3Name + " for an extra " + this.addition3Price);
        }
        if(this.addition4Name != null) {
            hamburgerPrice += this.addition4Price;
            System.out.println("Added " + this.addition4Name + " for an extra " + this.addition4Price);
        }

        return hamburgerPrice;
    }

    }

    // Helthy burger class
    package com.timbuchalka;

/**
 * Created by dev on 11/08/15.
 */
public class HealthyBurger extends Hamburger {

    private String healthyExtra1Name;
    private double healthyExtra1Price;

    private String healthyExtra2Name;
    private double healthyExtra2Price;

    public HealthyBurger(String meat, double price) {
        super("Healthy", meat, price, "Brown rye");
    }

    public void addHealthAddition1(String name, double price) {
        this.healthyExtra1Name = name;
        this.healthyExtra1Price = price;
    }

    public void addHealthAddition2(String name, double price) {
        this.healthyExtra2Name = name;
        this.healthyExtra2Price = price;
    }

    @Override
    public double itemizeHamburger() {
        double hamburgerPrice = super.itemizeHamburger();
        if(this.healthyExtra1Name != null) {
            hamburgerPrice += this.healthyExtra1Price;
            System.out.println("Added " + this.healthyExtra1Name + " for an extra " + this.healthyExtra1Price);
        }
        if(this.healthyExtra2Name != null) {
            hamburgerPrice += this.healthyExtra2Price;
            System.out.println("Added " + this.healthyExtra2Name + " for an extra " + this.healthyExtra2Price);
        }

        return hamburgerPrice;
    }
}


    // Delux burger class
    package com.timbuchalka;

/**
 * Created by dev on 11/08/15.
 */
public class DeluxeBurger extends Hamburger {
    public DeluxeBurger() {
        super("Deluxe", "Sausage & Bacon", 14.54, "White");
        super.addHamburgerAddition1("Chips", 2.75);
        super.addHamburgerAddition2("Drink", 1.81);
    }

    @Override
    public void addHamburgerAddition1(String name, double price) {
        System.out.println("Cannot not add additional items to a deluxe burger");
    }

    @Override
    public void addHamburgerAddition2(String name, double price) {
        System.out.println("Cannot not add additional items to a deluxe burger");
    }

    @Override
    public void addHamburgerAddition3(String name, double price) {
        System.out.println("Cannot not add additional items to a deluxe burger");
    }

    @Override
    public void addHamburgerAddition4(String name, double price) {
        System.out.println("Cannot not add additional items to a deluxe burger");
    }
}

// Test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {


        Hamburger hamburger = new Hamburger("Basic", "Sausage", 3.56, "White");
        double price = hamburger.itemizeHamburger();
        hamburger.addHamburgerAddition1("Tomato", 0.27);
        hamburger.addHamburgerAddition2("Lettuce", 0.75);
        hamburger.addHamburgerAddition3("Cheese", 1.13);
        System.out.println("Total Burger price is " + hamburger.itemizeHamburger());

        HealthyBurger healthyBurger = new HealthyBurger("Bacon", 5.67);
        healthyBurger.addHamburgerAddition1("Egg", 5.43);
        healthyBurger.addHealthAddition1("Lentils", 3.41);
        System.out.println("Total Healthy Burger price is  " + healthyBurger.itemizeHamburger());

        DeluxeBurger db = new DeluxeBurger();
        db.addHamburgerAddition3("Should not do this", 50.53);
        db.itemizeHamburger();



    }
}


/*Interface part 9   ( inner or abstract && interface)
first we make an interface. and write those method which was common.
then we implements that  method in other class .*/
// gearbox class
package com.timbuchalka;

/**
 * Created by dev on 27/09/15.
 */
public class Gearbox {

    private boolean clutchIsIn;

    public void operateClutch(boolean inOrOut) {
        this.clutchIsIn = inOrOut;
    }
}

// interface for telephone ( which include the commong behaviour b/w the deskphone and MobilePhone)

package com.timbuchalka;

/**
 * Created by dev on 27/09/15.
 */
public interface ITelephone { // there is no need to write acccess modifier.
    void powerOn();
    void dial(int phoneNumber);
    void answer();
    boolean callPhone(int phoneNumber);
    boolean isRinging();
}

// Desk phone class we override(implements) the method of interface
package com.timbuchalka;

/**
 * Created by dev on 27/09/15.
 */
public class DeskPhone implements ITelephone {

    private int myNumber;
    private boolean isRinging;

    public DeskPhone(int myNumber) {
        this.myNumber = myNumber;
    }

    @Override
    public void powerOn() {
        System.out.println("No action taken, desk phone does not have a power button");

    }

    @Override
    public void dial(int phoneNumber) {
        System.out.println("Now ringing " + phoneNumber + " on deskphone");

    }

    @Override
    public void answer() {
        if(isRinging) {
            System.out.println("Answering the desk phone");
            isRinging = false;
        }

    }

    @Override
    public boolean callPhone(int phoneNumber) {
        if(phoneNumber == myNumber) {
            isRinging = true;
            System.out.println("Ring ring");
        } else {
            isRinging = false;
        }

        return isRinging;
    }

    @Override
    public boolean isRinging() {
        return isRinging;
    }
}

// Mobile phone which is same as deskphone but there is alittle things is different
package com.timbuchalka;

/**
 * Created by Gigabyte on 12/8/2017.
 */
public class MobilePhone implements ITelephone {

    private int myNumber;
    private boolean isRinging;
    private boolean isOn = false;

    public MobilePhone(int myNumber) {
        this.myNumber = myNumber;
    }

    @Override
    public void powerOn() {
        isOn = true;
        System.out.println("Mobile phone powered up");

    }

    @Override
    public void dial(int phoneNumber) {
        if(isOn) {
            System.out.println("Now ringing " + phoneNumber + " on mobile phone.");
        } else {
            System.out.println("Phone is switched off");
        }

    }

    @Override
    public void answer() {
        if(isRinging) {
            System.out.println("Answering the mobile phone");
            isRinging = false;
        }

    }

    @Override
    public boolean callPhone(int phoneNumber) {
        if(phoneNumber == myNumber && isOn) {
            isRinging = true;
            System.out.println("Melody ring");
        } else {
            isRinging = false;
            System.out.println("Mobile phone not on or number different");
        }

        return isRinging;
    }

    @Override
    public boolean isRinging() {
        return isRinging;
    }
}

// Test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
        ITelephone timsPhone;
        timsPhone = new DeskPhone(123456);
        timsPhone.powerOn();
        timsPhone.callPhone(123456);
        timsPhone.answer();

        timsPhone = new MobilePhone(24565);
        timsPhone.powerOn();
        timsPhone.callPhone(24565);
        timsPhone.answer();

    }
}

// ArrayList challenge in 64 lecture Explanition

// Create a program that implements a playlist for songs
        // Create a Song class having Title and Duration for a song.
        // The program will have an Album class containing a list of songs.
        // The albums will be stored in an ArrayList
        // Songs from different albums can be added to the playlist and will appear in the list in the order
        // they are added.
        // Once the songs have been added to the playlist, create a menu of options to:-
        // Quit,Skip forward to the next song, skip backwards to a previous song.  Replay the current song.
        // List the songs in the playlist
        // A song must exist in an album before it can be added to the playlist (so you can only play songs that
        // you own).
        // Hint:  To replay a song, consider what happened when we went back and forth from a city before we
        // started tracking the direction we were going.
        // As an optional extra, provide an option to remove the current song from the playlist
        // (hint: listiterator.remove()

// Album Class
package com.timbuchalka;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by dev on 18/09/15.
 */
public class Album {
    private String name;
    private String artist;
    private ArrayList<Song> songs;

    public Album(String name, String artist) {
        this.name = name;
        this.artist = artist;
        this.songs = new ArrayList<Song>();
    }

    public boolean addSong(String title, double duration) {
        if(findSong(title) == null) {
            this.songs.add(new Song(title, duration));
            return true;
        }
        return false;
    }

    private Song findSong(String title) {
        for(Song checkedSong: this.songs) {
            if(checkedSong.getTitle().equals(title)) {
                return checkedSong;
            }
        }
        return null;
    }

    public boolean addToPlayList(int trackNumber, List<Song> playList) {
        int index = trackNumber -1;
        if((index >0) && (index <= this.songs.size())) {
            playList.add(this.songs.get(index));
            return true;
        }
        System.out.println("This album does not have a track " + trackNumber);
        return false;
    }

    public boolean addToPlayList(String title, List<Song> playList) {
        Song checkedSong = findSong(title);
        if(checkedSong != null) {
            playList.add(checkedSong);
            return true;
        }
        System.out.println("The song " + title + " is not in this album");
        return false;
    }

}

// Song class
package com.timbuchalka;

/**
 * Created by dev on 18/09/15.
 */
public class Song {
    private String title;
    private double duration;

    public Song(String title, double duration) {
        this.title = title;
        this.duration = duration;
    }

    public String getTitle() {
        return title;
    }

    @Override
    public String toString() {
        return this.title + ": " + this.duration;
    }
}

// Test class
package com.timbuchalka;

import java.util.*;

public class Main {

    private static List<Album> albums = new ArrayList<Album>();

    public static void main(String[] args) {


        Album album = new Album("Stormbringer", "Deep Purple");
        album.addSong("Stormbringer", 4.6);
        album.addSong("Love don't mean a thing", 4.22);
        album.addSong("Holy man", 4.3);
        album.addSong("Hold on", 5.6);
        album.addSong("Lady double dealer", 3.21);
        album.addSong("You can't do it right", 6.23);
        album.addSong("High ball shooter", 4.27);
        album.addSong("The gypsy", 4.2);
        album.addSong("Soldier of fortune", 3.13);
        albums.add(album);

        album = new Album("For those about to rock", "AC/DC");
        album.addSong("For those about to rock", 5.44);
        album.addSong("I put the finger on you", 3.25);
        album.addSong("Lets go", 3.45);
        album.addSong("Inject the venom", 3.33);
        album.addSong("Snowballed", 4.51);
        album.addSong("Evil walks", 3.45);
        album.addSong("C.O.D.", 5.25);
        album.addSong("Breaking the rules", 5.32);
        album.addSong("Night of the long knives", 5.12);
        albums.add(album);

        List<Song> playList = new Vector<Song>();
        albums.get(0).addToPlayList("You can't do it right", playList);
        albums.get(0).addToPlayList("Holy man", playList);
        albums.get(0).addToPlayList("Speed king", playList);  // Does not exist
        albums.get(0).addToPlayList(9, playList);
        albums.get(1).addToPlayList(8, playList);
        albums.get(1).addToPlayList(3, playList);
        albums.get(1).addToPlayList(2, playList);
        albums.get(1).addToPlayList(24, playList);  // There is no track 24

        play(playList);




    }

    private static void play(List<Song> playList) {
        Scanner scanner = new Scanner(System.in);
        boolean quit = false;
        boolean forward = true;
        ListIterator<Song> listIterator = playList.listIterator();
        if(playList.size() == 0) {
            System.out.println("No songs in playlist");
            return;
        } else {
            System.out.println("Now playing " + listIterator.next().toString());
            printMenu();
        }

        while(!quit) {
            int action = scanner.nextInt();
            scanner.nextLine();

            switch(action) {
                case 0:
                    System.out.println("Playlist complete.");
                    quit = true;
                    break;
                case 1:
                    if(!forward) {
                        if(listIterator.hasNext()) {
                            listIterator.next();
                        }
                        forward = true;
                    }
                    if(listIterator.hasNext()) {
                        System.out.println("Now playing " + listIterator.next().toString());
                    } else {
                        System.out.println("We have reached the end of the playlist");
                        forward = false;
                    }
                    break;

                case 2:
                    if(forward) {
                        if(listIterator.hasPrevious()) {
                            listIterator.previous();
                        }
                        forward = false;
                    }
                    if(listIterator.hasPrevious()) {
                        System.out.println("Now playing " + listIterator.previous().toString());
                    } else {
                        System.out.println("We are at the start of the playlist");
                        forward = true;
                    }
                    break;
                case 3:
                    if(forward) {
                        if(listIterator.hasPrevious()) {
                            System.out.println("Now replaying " + listIterator.previous().toString());
                            forward = false;
                        } else {
                            System.out.println("We are at the start of the list");
                        }
                    } else {
                        if(listIterator.hasNext()) {
                            System.out.println("Now replaying " + listIterator.next().toString());
                            forward = true;
                        } else {
                            System.out.println("We have reached the end of the list");
                        }
                    }
                    break;
                case 4:
                    printList(playList);
                    break;
                case 5:
                    printMenu();
                    break;

                case 6:
                    if(playList.size() >0) {
                        listIterator.remove();
                        if(listIterator.hasNext()) {
                            System.out.println("Now playing " + listIterator.next());
                        } else if(listIterator.hasPrevious()) {
                            System.out.println("Now playing " + listIterator.previous());
                        }
                    }
                    break;

            }
        }
    }

    private static void printMenu() {
        System.out.println("Available actions:\npress");
        System.out.println("0 - to quit\n" +
                "1 - to play next song\n" +
                "2 - to play previous song\n" +
                "3 - to replay the current song\n" +
                "4 - list songs in the playlist\n" +
                "5 - print available actions.\n" +
                "6 - delete current song from playlist");

    }


    private static void printList(List<Song> playList) {
        Iterator<Song> iterator = playList.iterator();
        System.out.println("================================");
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        System.out.println("================================");
    }

}


// Interface Good ex Challenge by using ArrayList

 // Create a simple interface that allows an object to be saved to some sort of storage medium.
        // The exact type of medium is not known to the interface (nor to the classes that implement it).
        // The interface will just specify 2 methods, one to return an ArrayList of values to be saved
        // and the other to populate the object's fields from an ArrayList.
        //
        // Create some sample classes that implement your saveable interface (we've used the idea of a game,
        // with Players and Monsters, but you can create any type of classes that you want).
        //
        // Override the toString() method for each of your classes so that they can be easily printed to enable
        // the program to be tested easier.
        //
        // In Main, write a method that takes an object that implements the interface as a parameter and
        // "saves" the values.
        // We haven't covered I/O yet, so your method should just print the values to the screen.
        // Also in Main, write a method that restores the values to a saveable object.
        // Again, we are not going to use Java file I/O; instead use the readValues() method below to
        // simulate getting values from a file  this allows you to type as many values as your class
        // requires, and returns an ArrayList.

// interface
package com.timbuchalka;

import java.util.List;

/**
 * Created by dev on 30/09/15.
 */
public interface ISaveable {
    List<String> write();
    void read(List<String> savedValues);

}

// player class   i writte first states then constructor makes then setter and getter then to string then i implement the method of interface.
package com.timbuchalka;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by dev on 30/09/15.
 */
public class Player implements ISaveable {
    private String name;
    private int hitPoints;
    private int strength;
    private String weapon;

    public Player(String name, int hitPoints, int strength) {
        this.name = name;
        this.hitPoints = hitPoints;
        this.strength = strength;
        this.weapon = "Sword";
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getHitPoints() {
        return hitPoints;
    }

    public void setHitPoints(int hitPoints) {
        this.hitPoints = hitPoints;
    }

    public int getStrength() {
        return strength;
    }

    public void setStrength(int strength) {
        this.strength = strength;
    }

    public String getWeapon() {
        return weapon;
    }

    public void setWeapon(String weapon) {
        this.weapon = weapon;
    }

    @Override
    public String toString() {
        return "Player{" +
                "name='" + name + '\'' +
                ", hitPoints=" + hitPoints +
                ", strength=" + strength +
                ", weapon='" + weapon + '\'' +
                '}';
    }

    @Override
    public List<String> write() {
        List<String> values = new ArrayList<String>();
        values.add(0, this.name);
        values.add(1, "" + this.hitPoints);
        values.add(2, "" + this.strength);
        values.add(3, this.weapon);

        return values;
    }

    @Override
    public void read(List<String> savedValues) {
        if(savedValues != null && savedValues.size() >0) {
            this.name = savedValues.get(0);
            this.hitPoints = Integer.parseInt(savedValues.get(1));
            this.strength = Integer.parseInt(savedValues.get(2));
            this.weapon = savedValues.get(3);
        }

    }

}

// Monstar class which is same as player
package com.timbuchalka;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by dev on 1/10/15.
 */
public class Monster implements ISaveable {
    private String name;
    private int hitPoints;
    private int strength;

    public Monster(String name, int hitPoints, int strength) {
        this.name = name;
        this.hitPoints = hitPoints;
        this.strength = strength;
    }

    public String getName() {
        return name;
    }

    public int getHitPoints() {
        return hitPoints;
    }

    public int getStrength() {
        return strength;
    }

    @Override
    public List<String> write() {
        ArrayList<String> values = new ArrayList<String>();
        values.add(0, this.name);
        values.add(1, "" + this.hitPoints);
        values.add(2, "" + this.strength);
        return values;
    }

    @Override
    public void read(List<String> savedValues) {
        if(savedValues != null && savedValues.size() > 0) {
            this.name = savedValues.get(0);
            this.hitPoints = Integer.parseInt(savedValues.get(1));
            this.strength = Integer.parseInt(savedValues.get(2));
        }

    }

    @Override
    public String toString() {
        return "Monster{" +
                "name='" + name + '\'' +
                ", hitPoints=" + hitPoints +
                ", strength=" + strength +
                '}';
    }
}

// Test class
package com.timbuchalka;

import java.util.ArrayList;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {


        Player tim = new Player("Tim", 10, 15);
        System.out.println(tim.toString());
        saveObject(tim);

        tim.setHitPoints(8);
        System.out.println(tim);
        tim.setWeapon("Stormbringer");
        saveObject(tim);
//        loadObject(tim);
        System.out.println(tim);

        ISaveable werewolf = new Monster("Werewolf", 20, 40);
        System.out.println("Strength = " + ((Monster) werewolf).getStrength());
        saveObject(werewolf);

    }

    public static ArrayList<String> readValues() {
        ArrayList<String> values = new ArrayList<String>();

        Scanner scanner = new Scanner(System.in);
        boolean quit = false;
        int index = 0;
        System.out.println("Choose\n" +
                "1 to enter a string\n" +
                "0 to quit");

        while (!quit) {
            System.out.print("Choose an option: ");
            int choice = scanner.nextInt();
            scanner.nextLine();
            switch (choice) {
                case 0:
                    quit = true;
                    break;
                case 1:
                    System.out.print("Enter a string: ");
                    String stringInput = scanner.nextLine();
                    values.add(index, stringInput);
                    index++;
                    break;
            }
        }
        return values;
    }

    public static void saveObject(ISaveable objectToSave) {
        for(int i=0; i<objectToSave.write().size(); i++) {
            System.out.println("Saving " + objectToSave.write().get(i) + " to storage device");
        }
    }

    public static void loadObject(ISaveable objectToLoad) {
        ArrayList<String> values = readValues();
        objectToLoad.read(values);
    }


}


// Exception Handling Lecture by sir Mohammad Ali khan

package exceptionss;

public class BankAccount {

	int withdrawAmount;
	int transferAmount;

	public void setTransferAmount(int transferAmount) {
		this.transferAmount = transferAmount;
	}

	public int getTransferAmount() {
		return transferAmount;
	}

	public void setWithdrawAmount(int withdrawAmount) {

		if (withdrawAmount < 0) {
			throw new IllegalArgumentException("Please enter amount greater than 0. ");
		}else {
			this.withdrawAmount = withdrawAmount;
		}

	}

	public int getWithdrawAmount() {
		return withdrawAmount;
	}

}

// Test CLASS
package exceptionss;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Application {

	public static void main(String[] args) {

		//every software build by developers have some specific flow
		//abnormal flow ( mean if the user not give required input then there msg show to user you put a wrong input try back)
		//events -- something on which software needs to perform some action
		//1. button click, mouse click
		//2. method call
		//to handle abnormal flows, we use (try, catch) to handle exceptions
		//be default, Java provides try, catch structure

		Scanner scanner = new Scanner(System.in);

		BankAccount bac = new BankAccount();

		//compiler has no issues, correct compiling and running but,
		//as a developer, there may be an exception
		//unchecked exceptions - runtime exceptions

		//System.out.println(bac.getWithdrawAmount());

		try {
			System.out.println("Enter the amount to deposit : ");
			bac.setWithdrawAmount(scanner.nextInt());
			System.out.println("Enter the amount to transfer : ");
			bac.setTransferAmount(scanner.nextInt());
			//in case of exception, it is java that is passing that exception information to catch block
			//in case of abnormal event, exception information is carried in an object of type exception
		}catch(InputMismatchException | IllegalArgumentException e) {
			System.out.println("Please provide valid input. " );
		}finally {
			System.out.println("I run anyway.");
		}

		//System.out.println(bac.getTransferAmount());

	}

}


// Abstract classes

// Animal class
package com.timbuchalka;

/**
 * Created by dev on 7/10/2015.
 */
public abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void eat();
    public abstract void breathe();

    public String getName() {
        return name;
    }
}

// Abstract classes challenges ( most part of data structure include)

    // For this challenge, create an abstract class to define items that can be stored in a tree.
        // The class should contain 2 references to items which will represent the next and previous
        // items (in the case of a linked tree).
        // I.e., if you call your abstract class ListItem, then it would have 2 member variables of
        // type ListItem that will hold references to the next/right and previous/left ListItems.
        //
        // The abstract class will also need to hold a value - try to be as flexible as possible
        // when defining the type of this value.
        //
        // The class will also need methods to move to the next item and back to the previous item,
        // and methods to set the next and previous items.
        //
        // You should also specify a compareTo() method that takes a parameter of the same type as the
        // class and returns 0 if the values are equal, greater than zero if the value sorts greater than
        // the parameter and less than zero if it sorts less than the parameter.
        //
        // Create a concrete class from your abstract tree item class and use this in a LinkedList
        // class to implement a linked tree that will add items in order (so that they are sorted
        // alphabetically). Duplicate values are not added.
        //
        // Note that you are creating your own LinkedList class here, not using the built-in Java one..
        //
        // The rules for adding an item to the linked tree are:
        //  If the head of the tree is null, make the head refer to the item to be added.
        //  If the item to be added is less than the current item in the tree, add the item before the
        //      current item (i.e., make the previous item's "next" refer to the new item, and the new item's
        //      "next" refer to the current item).
        //  If the item to be added is greater than the current item, move onto the next item and compare
        //      again (if there is no next item then that is where the new item belongs).
        //
        // Care will be needed when inserting before the first item in the tree (as it will not have a previous
        // item).
        //
        // You will also need a method to remove an item from the tree.
        //
        // Hint: If you are creating classes with names such as List, LinkedList, Node etc, make sure that
        // you create your classes before referring to them. In previous videos we have often referred to
        // classes that we create later, but if you use names that IntelliJ recognises as Java classes (such
        // as LinkedList) then it will create imports for them and possibly cause you problems later.
        //
        // Optional: create a class to use your concrete class to implement a Binary Search Tree:
        // When adding items to a Binary Search Tree, if the item to be added is less than the current item
        // then move to the left, if it is greater than the current item then move to the right.
        //
        // The new item is added when an attempt to move in the required direction would involve following a
        // null reference.
        // Once again, duplicates are not allowed.
        //
        // Hint: to avoid typing loads of "addItem" lines, split a string into an array and create your tree in
        // a loop as in the example below.
        //
//
package com.timbuchalka;

/**
 * Created by dev on 11/10/2015.
 */
public abstract class ListItem {
    protected ListItem rightLink = null;
    protected ListItem leftLink = null;

    protected Object value;

    public ListItem(Object value) {
        this.value = value;
    }

    abstract ListItem next();
    abstract ListItem setNext(ListItem item);
    abstract ListItem previous();
    abstract ListItem setPrevious(ListItem item);

    abstract int compareTo(ListItem item);

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}

//

package com.timbuchalka;

/**
 * Created by dev on 11/10/2015.
 */
public class MyLinkedList implements NodeList {

    private ListItem root = null;

    public MyLinkedList(ListItem root) {
        this.root = root;
    }

    @Override
    public ListItem getRoot() {
        return this.root;
    }

    @Override
    public boolean addItem(ListItem newItem) {
        if (this.root == null) {
            // The list was empty, so this item becomes the head of the list
            this.root = newItem;
            return true;
        }

        ListItem currentItem = this.root;
        while (currentItem != null) {
            int comparison = (currentItem.compareTo(newItem));
            if (comparison < 0) {
                // newItem is greater, move right if possible
                if (currentItem.next() != null) {
                    currentItem = currentItem.next();
                } else {
                    // there is no next, so insert at end of list
                    currentItem.setNext(newItem).setPrevious(currentItem);
                    return true;
                }
            } else if (comparison > 0) {
                // newItem is less, insert before
                if (currentItem.previous() != null) {
                    currentItem.previous().setNext(newItem).setPrevious(currentItem.previous());
                    newItem.setNext(currentItem).setPrevious(newItem);
                } else {
                    // the node with a previous is the root
                    newItem.setNext(this.root).setPrevious(newItem);
                    this.root = newItem;
                }
                return true;
            } else {
                // equal
                System.out.println(newItem.getValue() + " is already present, not added.");
                return false;
            }
        }

        return false;
    }

    @Override
    public boolean removeItem(ListItem item) {
        if (item != null) {
            System.out.println("Deleting item " + item.getValue());
        }

        ListItem currentItem = this.root;
        while (currentItem != null) {
            int comparison = currentItem.compareTo(item);
            if (comparison == 0) {
                // found the item to delete
                if (currentItem == this.root) {
                    this.root = currentItem.next();
                } else {
                    currentItem.previous().setNext(currentItem.next());
                    if (currentItem.next() != null) {
                        currentItem.next().setPrevious(currentItem.previous());
                    }
                }
                return true;
            } else if (comparison < 0) {
                currentItem = currentItem.next();
            } else { // comparison > 0
                // We are at an item greater than the one to be deleted
                // so the item is not in the list
                return false;
            }
        }

        // We have reached the end of the list
        // Without finding the item to delete
        return false;
    }

    @Override
    public void traverse(ListItem root) {
        if (root == null) {
            System.out.println("The list is empty");
        } else {
            while (root != null) {
                System.out.println(root.getValue());
                root = root.next();
            }
        }
    }
}

//
package com.timbuchalka;

/**
 * Created by dev on 11/10/2015.
 */
public class Node extends ListItem {

    public Node(Object value) {
        super(value);
    }

    @Override
    ListItem next() {
        return this.rightLink;
    }

    @Override
    ListItem setNext(ListItem item) {
        this.rightLink = item;
        return this.rightLink;
    }

    @Override
    ListItem previous() {
        return this.leftLink;
    }

    @Override
    ListItem setPrevious(ListItem item) {
        this.leftLink = item;
        return this.leftLink;
    }

    @Override
    int compareTo(ListItem item) {
        if(item != null) {
            return ((String) super.getValue()).compareTo((String) item.getValue());
        } else {
            return -1;
        }
    }
}
//

package com.timbuchalka;

/**
 * Created by dev on 11/10/2015.
 */
public interface NodeList {
    ListItem getRoot();
    boolean addItem(ListItem item);
    boolean removeItem(ListItem item);
    void traverse(ListItem root);
}


//
package com.timbuchalka;

/**
 * Created by dev on 15/10/2015.
 */
public class SearchTree implements NodeList {

    private ListItem root = null;

    public SearchTree(ListItem root) {
        this.root = root;
    }

    @Override
    public ListItem getRoot() {
        return this.root;
    }

    @Override
    public boolean addItem(ListItem newItem) {
        if (this.root == null) {
            // the tree was empty, so our item becomes the head of the tree
            this.root = newItem;
            return true;
        }

        // otherwise, start comparing from the head of the tree
        ListItem currentItem = this.root;
        while (currentItem != null) {
            int comparison = (currentItem.compareTo(newItem));
            if (comparison < 0) {
                // newItem is greater, move right if possible
                if (currentItem.next() != null) {
                    currentItem = currentItem.next();
                } else {
                    // there's no node to the right, so add at this point
                    currentItem.setNext(newItem);
                    return true;
                }
            } else if (comparison > 0) {
                // newItem is less, move left if possible
                if (currentItem.previous() != null) {
                    currentItem = currentItem.previous();
                } else {
                    // there's no node to the left, so add at this point
                    currentItem.setPrevious(newItem);
                    return true;
                }
            } else {
                // equal, so don't add
                System.out.println(newItem.getValue() + " is already present");
                return false;
            }
        }
        // we can't actually get here, but Java complains if there's no return
        return false;
    }

    @Override
    public boolean removeItem(ListItem item) {
        if (item != null) {
            System.out.println("Deleting item " + item.getValue());
        }
        ListItem currentItem = this.root;
        ListItem parentItem = currentItem;

        while (currentItem != null) {
            int comparison = (currentItem.compareTo(item));
            if (comparison < 0) {
                parentItem = currentItem;
                currentItem = currentItem.next();
            } else if (comparison > 0) {
                parentItem = currentItem;
                currentItem = currentItem.previous();
            } else {
                // equal: we've found the item so remove it
                performRemoval(currentItem, parentItem);
                return true;
            }
        }
        return false;
    }


    private void performRemoval(ListItem item, ListItem parent) {
        // remove item from the tree
        if (item.next() == null) {
            // no right tree, so make parent point to left tree (which may be null)
            if (parent.next() == item) {
                // item is right child of its parent
                parent.setNext(item.previous());
            } else if (parent.previous() == item) {
                // item is left child of its parent
                parent.setPrevious(item.previous());
            } else {
                // parent must be item, which means we were looking at the root of the tree
                this.root = item.previous();
            }
        } else if (item.previous() == null) {
            // no left tree, so make parent point to right tree (which may be null)
            if (parent.next() == item) {
                // item is right child of its parent
                parent.setNext(item.next());
            } else if (parent.previous() == item) {
                // item is left child of its parent
                parent.setPrevious(item.next());
            } else {
                // again, we are deleting the root
                this.root = item.next();
            }
        } else {
            // neither left nor right are null, deletion is now a lot trickier!
            // From the right sub-tree, find the smallest value (i.e., the leftmost).
            ListItem current = item.next();
            ListItem leftmostParent = item;
            while (current.previous() != null) {
                leftmostParent = current;
                current = current.previous();
            }
            // Now put the smallest value into our node to be deleted
            item.setValue(current.getValue());
            // and delete the smallest
            if (leftmostParent == item) {
                // there was no leftmost node, so 'current' points to the smallest
                // node (the one that must now be deleted).
                item.setNext(current.next());
            } else {
                // set the smallest node's parent to point to
                // the smallest node's right child (which may be null).
                leftmostParent.setPrevious(current.next());
            }
        }
    }

    @Override
    public void traverse(ListItem root) {
        // recursive method
        if (root != null) {
            traverse(root.previous());
            System.out.println(root.getValue());
            traverse(root.next());
        }

    }
}
// test class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {


        SearchTree tree = new SearchTree(null);
        tree.traverse(tree.getRoot());
        // Create a string data array to avoid typing loads of addItem instructions:
        String stringData = "5 7 3 9 8 2 1 0 4 6";
//        String stringData = "Darwin Brisbane Perth Melbourne Canberra Adelaide Sydney Canberra";


        String[] data = stringData.split(" ");
        for (String s : data) {
            tree.addItem(new Node(s));
        }


        tree.traverse(tree.getRoot());
        tree.removeItem(new Node("3"));
        tree.traverse(tree.getRoot());

        tree.removeItem(new Node("5"));
        tree.traverse(tree.getRoot());

        tree.removeItem(new Node("0"));
        tree.removeItem(new Node("4"));
        tree.removeItem(new Node("2"));
        tree.traverse(tree.getRoot());

        tree.removeItem(new Node("9"));
        tree.traverse(tree.getRoot());
        tree.removeItem(new Node("8"));
        tree.traverse(tree.getRoot());
        tree.removeItem(new Node("6"));
        tree.traverse(tree.getRoot());
        tree.removeItem(tree.getRoot());
        tree.traverse(tree.getRoot());
        tree.removeItem(tree.getRoot());
        tree.traverse(tree.getRoot());
    }
}

//  Exceptional Handling by Tim java Udemy.
package practiceS2;
// if you want to make method in main class so you have to write b/c it's defend related to this class.
// if you did not write that's also correct but written is good practice for programmer.
import java.util.InputMismatchException;
import java.util.Scanner;

public class Application {

    public static void main(String[] args ) {
//    int x = 98;
//    int y = 0;
//        System.out.println(divideByL(x,y));
//        System.out.println(divideEAFP(x,y));
//        System.out.println(divide(x,y));

        // Now i want to takes number from user.
        int x = getIntEAHL();
        System.out.println("x is " + x);
    }

    private static int getInt(){
        Scanner s = new Scanner (System.in);
        return s.nextInt();
    }
    // This function do that if i give text which is not a number then they print value of x = 0;
    private static int getIntByL(){
        Scanner s = new Scanner (System.in);
        boolean isValid = true;
        System.out.println("Please enter an Integer ");
        String Input = s.next();
        for (int i = 0 ; i<Input.length(); i++){
            if(!Character.isDigit(Input.charAt(i))){
                isValid = false;
                break;
            }
        }
        if(isValid){
            return Integer.parseInt(Input);
        }
        return 0;
    }
   // we can do the above work easy through exception (try and catch) the efficient way of Handling exceptional handling.
    private static int getIntEAHL() {
        Scanner s = new Scanner(System.in);
        System.out.println("Please enter an Integer:  ");
        try{
            return s.nextInt();
        } catch(InputMismatchException e){
            return 0;

        }
    }


    private static  int divideByL(int x, int y){
        if (y != 0){
            return x/y;
        }
        return 0;
    }
    private static  int divideEAFP(int x, int y){
        try{
          return x/y;
        }catch(ArithmeticException e){
            return 0;
        }

    }
    private static int divide (int x, int y){
        return x/y;
    }

}


package practiceS2;
// projectName: Stack trace and call stack ( those when we give wrong input then they print some types of exception in terminal)
/*
like that .
like that . in scanner .java class
Exception in thread "main" java.util.InputMismatchException
	at java.base/java.util.Scanner.throwFor(Scanner.java:939)
	at java.base/java.util.Scanner.next(Scanner.java:1594)
	at java.base/java.util.Scanner.nextInt(Scanner.java:2258)
	at java.base/java.util.Scanner.nextInt(Scanner.java:2212)
	at practiceS2.Application.getInt(Application.java:25)
	at practiceS2.Application.divide(Application.java:16)
	at practiceS2.Application.main(Application.java:9)
 */

import java.util.InputMismatchException;
import java.util.Scanner;

public class Application {

    public static void main(String[] args ) {
        int result = divide();
        System.out.println(result);
    }

    public static int divide (){
        // one time call and store value in x then call to y  then print the value of
        // x and y then x by y.
        int x = getInt();
        int y = getInt();
        System.out.println("x is " + x + ", y is "+ y );
        return x/y;
    }

    public static int getInt(){
        Scanner s = new Scanner(System.in);
        System.out.println("please enter an Integer:  ");
        return s.nextInt();
    }

}


package practiceS2;


import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Application {

    public static void main(String[] args ) {
            int result = divide();
            System.out.println(result);
        }

        private static int divide() {
            int x, y;
            try {
                x = getInt();
                y = getInt();
            } catch(NoSuchElementException e) {
                throw new ArithmeticException("no suitable input");
            }
            System.out.println("x is " + x + ", y is " + y);
            try {
                return x / y;
                // if we give one number and this num divide by zero they print below massage
            } catch(ArithmeticException e) {
                throw new ArithmeticException("attempt to divide by zero");
            }
        }

        private static int getInt() {
            Scanner s = new Scanner(System.in);
            System.out.println("Please enter an integer ");
            while(true) {
                try {
                    return s.nextInt();
                } catch(InputMismatchException e) {
                    // go round again.  Read past the end of line in the input first
                    s.nextLine();
                    System.out.println("Please enter a number using only the digits 0 to 9 ");
                }
            }
    }
}


// Multiple catch handling.
package practiceS2;


import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Application {

    public static void main(String[] args ) {
        try {
            int result = divide();
            System.out.println(result);
            // you can handle two exception once like that.
        } catch(ArithmeticException | NoSuchElementException e) {
            System.out.println(e.toString());
            System.out.println("Unable to perform division, autopilot shutting down");
        }
    }

    private static int divide() {
        int x, y;
//        try {
        x = getInt();
        y = getInt();
        System.out.println("x is " + x + ", y is " + y);
        return x / y;
//        } catch(NoSuchElementException e) {
//            throw new ArithmeticException("no suitable input");
//        } catch(ArithmeticException e) {
//            throw new ArithmeticException("attempt to divide by zero");
//        }
    }

    private static int getInt() {
        Scanner s = new Scanner(System.in);
        System.out.println("Please enter an integer ");
        while(true) {
            try {
                return s.nextInt();
            } catch(InputMismatchException e) {
                // go round again.  Read past the end of line in the input first
                s.nextLine();
                System.out.println("Please enter a number using only the digits 0 to 9 ");
            }
        }

    }
}


// Output
//if you write ctrl+d

/*

^D
java.util.NoSuchElementException
Unable to perform division, autopilot shutting down
*/


// Project  of simple calculator by using function my self
package ProjPrac;

import java.util.Scanner;

public class calculator {

 Scanner sc = new Scanner(System.in);

    public int addition(){
        System.out.println("Enter 1st numbers ");
        int numbers1 = sc.nextInt();

        System.out.println("Enter 2nd numbers ");
        int numbers2 = sc.nextInt();
        return numbers1 + numbers2;

    }

    public int multiplication(){
        System.out.println("Enter 1st numbers ");
        int numbers1 = sc.nextInt();

        System.out.println("Enter 2nd numbers ");
        int numbers2 = sc.nextInt();
        return  numbers1 * numbers2;
    }
    public int subtraction(){
        System.out.println("Enter 1st numbers ");
        int numbers1 = sc.nextInt();

        System.out.println("Enter 2nd numbers ");
        int numbers2 = sc.nextInt();
        return numbers1 - numbers2;
    }

    public int division(){
        System.out.println("Enter 1st numbers ");
        int numbers1 = sc.nextInt();

        System.out.println("Enter 3nd numbers ");
        int numbers2 = sc.nextInt();
        return  numbers1 / numbers2;
    }



}
// main class
package ProjPrac;


import java.util.Scanner;

public class Application {
  private static Scanner inp = new Scanner(System.in);
    public static void main(String[] args) {

       calculator cal = new calculator();
        System.out.println("addition = " +cal.addition());
        System.out.println("substruction= " +cal.subtraction());
        System.out.println("multiplication = " +cal.multiplication());
        System.out.println("division = " + cal.division());
    }
}
// Enum Lecture By Sir M- Ali Khan

//Use enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.
//An enum cannot be used to create objects, and it cannot extend other classes (but it can implement interfaces).
package lectureEnum;

import java.util.EnumSet;

public class App {

	public static void main(String[] args) {

		//Enumeration

		/*
		 * 1. values that are fixed or a list is fixed or anything that is fixed and to be used, we take
		 * advantage of using a special data type provided by Java i.e., enum / constants
		 * 2. if something is fixed, then it is usually final
		 * 3. enum data types cannot by instantiated / we can't create an object, but we can declare it
		 * 4. enum list implicitly static, final, public
		 * 5. compiler can help you out to catch an entry that is not in the list
		 * 6. Iterate the full list / for each loop
		 * 7. by default, a static method called values() [in array form] is available to all enum types
		 * */




		WorkingLevels category = WorkingLevels.level1;
		System.out.println("Level 1 Details");
		System.out.println(category.getName());


	/*	SkypeStatus status;

		for (SkypeStatus s : SkypeStatus.values()) {
			System.out.println(s);
		}

		for (SkypeStatus ss : EnumSet.range(SkypeStatus.online, SkypeStatus.offline)) {
			System.out.println(ss);
		}

		checkStatus();

		//SkypeStatus status1 = SkypeStatus.available;
		//System.out.println(status1);*/

	}

	public static SkypeStatus checkStatus() {
		return SkypeStatus.available;
	}

}


// Skype Status Class
package lectureEnum;

public enum SkypeStatus {

	available, online, offline, busy

	//two things in a constructor in this scenario if you haven't specified anything
	//1. name
	//2. index values (starting from 0)
}

//  Working Levels
package lectureEnum;

public enum WorkingLevels {

	level1("Student",8), level2("Permit holder", 40);

	private String name;
	private int workingHours;

	//enum constructor is private, means you cannot call it from outside

	private WorkingLevels(String name, int workingHours) {
		this.name = name;
		this.workingHours = workingHours;
	}

	public String getName() {
		return name;
	}


}



//Enum in java

package practiceS2;

public enum Season {
   Winter, Spring, Summer, Fall

 }

package practiceS2;

public class Application {

    public static void main(String[] args ) {
   Season S = Season.Fall;// enum name var name = enum.enum type;
        System.out.println(S);

    }
}

// Enum example with constructor and instance variable
package practiceS2;

public enum Season {
   Winter, Spring, Summer, Fall;
   // you can give constrctor or instance variable and method and
   // even implements interface
private int value;
   // constructor
   private int Season (int value){
      this.value = value;
   }

}



package practiceS2;

public class Application {

    public static void main(String[] args ) {
    // for each loop
        for (Season s : Season.value())
        System.out.println(s+ ""+ s.value);

    }
}

// Enum class Practice Question
// Que find the latitude and longitude of pakistan famouse cityes by using enum.

// city class
package enumTasks;

public enum Cities {

	KARACHI("KARACHI","24.8607 N","67.0011 E"),LAHORE("LAHORE","31.5204 N","74.3587 E"),ISLAMABAD("ISLAMABAD","33.6844 N", "73.0479 E"),QUETTA("QUETTA","30.1798 N", "66.9750 E"),PESHAWAR("PESHAWAR","34.0151 N", "71.5249 E");

	private String cityName;
	private String longitude;
	private String lattitude;

	private Cities(String cityName,String longitude,String lattitude)
	{
		this.cityName = cityName;
		this.longitude = longitude;
		this.lattitude = lattitude;
	}

	public String getCityName() {
		return cityName;
	}

	public String getLongitude() {
		return longitude;
	}

	public String getLattitude() {
		return lattitude;
	}




}

// Main or test class
package enumTasks;

import java.util.InputMismatchException;
import java.util.Scanner;

public class App {
	public static void main(String[] args) {
		System.out.println("1.KARACHI\n2.LAHORE\n3.ISLAMABAD\n4.QUETTA\n5.PESHAWAR");
		while(true)
		{
			Scanner in = new Scanner(System.in);
			System.out.print("\nEnter City Number: ");
			try
			{
				int cityNum = in.nextInt();
				if(cityNum==0)
					throw new InputMismatchException();

				Cities city = Cities.values()[cityNum - 1];
				System.out.println("\nCity Name: " + city.getCityName());
				System.out.println("Longitude: " + city.getLongitude());
				System.out.println("Lattitude: " + city.getLattitude());
				break;

			}
			catch(ArrayIndexOutOfBoundsException | InputMismatchException exp)
			{
				if(exp instanceof InputMismatchException)
				{
					System.out.println("Please enter valid number");
				}
				else if(exp instanceof ArrayIndexOutOfBoundsException)
				{
					System.out.println("The list contain only 5 Cities");
				}
			}
	}
	}


}


//      File Handling In java By M. Ali khan

package Terminal;

import java.io.*;

public class App {

    public static void main(String[] args) throws IOException {
        {
            /*File Handling in Java
             *if you need to process the data permanently (data persistence), then there are two options
             *1. database 2. file
             *whenever you are working on your programs, these programs are loaded in RAM which is volatile
             *to process means (either read or write)
             *today's focus is only on text
             *Reading (3 options)
             *Writing (3 options)
             *1. FileOutputStream class (it only writes characters in files and nothing else)
             *2. FileWriter class (it writes numbers - integers) it is a subclass or child of FileOutputStream
             *3. BufferedWriter class
             * whenever a file is read or write to, it is usually done in characters (two options , byte stream and character stream)
             *File -- is actually a class in Java that lets you perform operations on files (metadata - info regarding files)
             *to provide a path (two options 1. D:/ 2. D:\\) \n,t
             * */

            File file = new File("E:/6th Semester/OOP SP21/test.txt");

            if (file.exists()) {
                System.out.println("File alraedy exist.");
            } else {
                file.createNewFile();
                System.out.println("File successfully created.");
            }

		/*System.out.println(file.getAbsolutePath());
		System.out.println(file.getName());
		System.out.println(file.length()); //return in bytes*/


            FileOutputStream fos = new FileOutputStream("D:/Java21/test.txt", true); //true is a value to append
            FileWriter fw = new FileWriter(file, true);
            BufferedWriter bw = new BufferedWriter(fw); //there are only two constructors

              //  writting data on file
            String country = "Pakistan";
            String city = "Peshawar";

            System.out.println("Writing begins.");

            char c[] = country.toCharArray();
            byte data[] = city.getBytes();


            for (int i = 0; i < country.length(); i++) {
                fos.write(c[i]);
            }

            fos.write(data);
            //fos.write(12);
            fw.append("12");
            bw.write(country);
            bw.close();

            fw.close();//it ensures the processing on file copy in RAM to be saved on hard disk


		/*Scanner input = new Scanner(System.in);
		System.out.println("Enter your first number :");
		int input1 = input.nextInt();
		System.out.println("Enter your second number :");
		int input2 = input.nextInt();*/


        }

    }

}


// MyPractice of File Handling source w3 school

// File creation in java
package Terminal;

//import java.io.*;

import java.io.File;
import java.io.IOException;

public class App {

    public static void main(String[] args) throws IOException {
        try {
            File file = new File("E:/6th Semester/OOP SP21/test2.txt");
            if (file.createNewFile()) {
                System.out.println("file is Successfully created   : " + file.getName());
            }else {
                System.out.println("File is already existed");
            }
        } catch (IOException e){
            System.out.println("An error Occured .");
            e.printStackTrace();
        }
    }
}





// Write to a file
package Terminal;

//import java.io.*;

import java.io.*;

public class App {

    public static void main(String[] args) throws IOException {
        try {
            FileWriter myWriter = new FileWriter("E:/6th Semester/OOP SP21/test2.txt");
            myWriter.write("Files in jave might be tricky, but it is fun enough!");
            myWriter.close();
            System.out.println("Succefully wrote to the files");

            } catch (IOException e){
            System.out.println("An error Occured .");
            e.printStackTrace();
        }

    }

}


// Read data from a file .
package Terminal;

//import java.io.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Scanner;

public class App {

    public static void main(String[] args) throws IOException {
        try {
            File myObj = new File("E:/6th Semester/OOP SP21/test2.txt");
            Scanner myReader = new Scanner(myObj);// scanner obj and pass into file obj
            while (myReader.hasNextLine()) { // and save this in one variable
                String data = myReader.nextLine();
                System.out.println(data);
            }
            myReader.close();// after reading close the file .
        }catch(FileNotFoundException e){
            System.out.println("An error Occured");
            e.printStackTrace();
        }

    }
}


// Deleting a file.
package Terminal;

//import java.io.*;

import java.io.File;


public class App {

    public static void main(String[] args)  {
        File file = new File ("E:/6th Semester/OOP SP21/test2.txt");
        if (file.delete()){
            System.out.println("Deleted The folder: "+ file.getName());

        }else{
            System.out.println("Failed to delete the file .");
        }


        //  Lec 2 About File Handling ..

        package Terminal;

//import java.io.*;

import java.io.*;


public class App {

    public static void main(String[] args) throws IOException  {
        File file = new File("E:/6th Semester/OOP SP21/sports.txt");
        if (file.createNewFile()) {
            System.out.println("File successfully created.");
        }else{
            System.out.println("File already exists.");
        }
        FileOutputStream fo = new FileOutputStream(file, true);
        FileInputStream fin = new FileInputStream(file);

        FileReader fr = new FileReader(file);
        BufferedReader br = new BufferedReader(fr);


        String sports = "cricket";

        byte v[] = sports.getBytes();
        fo.write(v);

        int n;

        //System.out.println("writing using character array");
        char c[] = sports.toCharArray();
        for (n=0;n<sports.length();n++) {
            fo.write(c[n]);
        }


        //reading using FileInputStream
        //negative index will prompt you the end of file
        System.out.println("Reading using FileInputStream.");
        do {
            n=fin.read(); //.read method returns the numeric representation of a character
            System.out.print((char)n);
        }while(n!=-1);


        System.out.print("Reading using BufferedReader.");
        while ((n=br.read())!=-1) {
            System.out.print((char)n);
        }
    }
}




    }
}


// Practice of write read  and buffered
package Terminal;

import java.io.*;

public class App {
    public static void main(String[] args) throws IOException  {
     File file = new File ("E:/6th Semester/OOP SP21/sports1.txt");
     boolean newFile = file.createNewFile();
     if (newFile){
         System.out.println("File is succesfully Created!");
     }else {
         System.out.println("File is already created !");
     }
    // they takes two paramater first obj and the next is boolean value if it is false they write once if it is true they write again and again .
     //   FileOutputStream = write
     FileOutputStream fos = new FileOutputStream (file,false);
     // FileInputStream same as fileOutputStream. but they takes one paramater.
     // fILEInputStrem = read
      FileInputStream fin = new FileInputStream(file);

      FileReader fr = new FileReader(file); //takes one paramater
      BufferedReader br =  new BufferedReader(fr); // we will pass the above obj in Buffer reader

     String sports = "cricket is my passion";// i want to write this data in this file.

     byte[] v = sports.getBytes();// i create array of byte whice is store  byte
     fos.write(v);

     int n;
        System.out.println("Writting using character  or file Output  Stream.");

        // If you want to store above string again and again then we takes another char array.
     char c[] = sports.toCharArray();
     for (n=0; n<sports.length(); n++){
        fos.write(c[n]);
     }

     // Reading Using FileInputStream = read
        System.out.println("Reading using file input stream.");
     do {
         n = fin.read();
         System.out.print((char)n );
     } while (n!= -1);

     // Reading using BufferReader
        System.out.println("   Reading Using BufferReader ");
        while((n = br.read())!=-1){
            System.out.print((char)n);// when you want to print array you must write within brackets array type and outside the bracket name of array.s
        }

    }
}


//     Java Generic And Collection  by M. Ali khan   lecture
// Generic Method
package generics;

public class App {

	public static void main(String[] args) {

		//we cannot operate on primitive data types..... a very very important point
		//it works on wrapper classes (basically it gives you the option to operate on Objects)
		//Polymorphism, interfaces, classes (generic story revolve around these concept)
		//generic methods

		/*GenericMethods gm = new GenericMethods();

		String employees[] = {"Officer grade", "Staff grade", "Administration"};
		gm.printRecords(employees);

		Integer employeesScale[] = {1,2,3,4}; //values 1,2,3, and 4 are now treated as Integer objects
		gm.printRecords(employeesScale);

		Double employeeSalaryRange[] = {90800.230,40000.235,70000.658};
		gm.printRecords(employeeSalaryRange);


		Integer a = 2;
		Integer b = 3;
		Integer c = 4;


		System.out.println(gm.largestNumber(a,b,c));*/




		//Generic class discussion

		//challenge
		//how to create objects? how to tell a class of which type of object a class holds

		GenericClass<Integer> honda = new GenericClass<Integer>();

		honda.setModel(2021);
		System.out.println("Printing for Honda.");
		System.out.println(honda.getModel());


		GenericClass<String> toyota = new GenericClass<String>();
		System.out.println("Printing for Toyota.");
		toyota.setModel("Covid Car.");
		System.out.println(toyota.getModel());


	}

}
// Generic Methods    on 28/05/021    by M- ali khan
package generics;

public class GenericMethods {


	//generic methods
	//in any method, there are few things specific to that method (argument type, return type)
	//before return type, use generic letter in angular brackets <>

	public <G> void printRecords(G[] record) {

		for (G r : record) {
			System.out.println(r);
		}

	}

	//you cannot directly perform mathematical operations on objects, especially in generic methods

	public <T extends Comparable<T>> T largestNumber(T a, T b, T c) {

		//unbox - wrong - after unbox, you will have a primitive type, but you are inside a generic method
		//only will work if you are to use Number class with generic type
		//so, it will not work

		T largest = a;

		if (b.compareTo(largest) > 0) {
			largest = b;
		}
		if (c.compareTo(largest) > 0) {
			largest = b;
		}

		return largest;
	}








	//non-generic method, a return type is different and an argument type is different

	/*public void printRecords(String[] record) {

		for (int i=0;i<record.length;i++) {
			System.out.println(record[i]);
		}

		System.out.println("Printing using for each loop.");
		for(String r:record) {
			System.out.println(r);
		}
	}

	public void printRecords(int[] record) {

		for (int r : record) {
			System.out.println(r);
		}

	}

	public void printRecords(double[] record) {

		for (double r : record) {
			System.out.println(r);
		}
	}*/
}


// Generic class and collection  on 28/05/021    by M- ali khan
package generics;

public class GenericClass<T> {

	//1. states  -  data
	//2. methods -  behavior

	//example, a car model -- 2013,2017, etc.. (integers) - Honda
	//another car -- but its a car -- vitz, priyus, gli, xli, etc... (Strings) - Toyota

	T model;

	public void setModel(T model) {
		this.model = model;
	}

	public T getModel() {
		return model;
	}

	/*
	public void setModel(int model) {
		this.model = model;
	}

	public int getModel() {
		return model;
	}
	*/

	//Collection Framework in Java
	//why is this framework available?

	//ArrayList instead of Arrays ???
	//1. index management auto
	//2. size expandable
	//3. there are set of methods that enables you to quickly perform some actions using ArrayList but not arrays

	//in general, whenever you are manipulating data inside a class, you need a method to set the data and you
	//need a method to get the data
	//if you are setting a data, then if you don't have any pre-defined methods, then it becomes difficult
	//for example, if you are inserting values in an array, then you need to write your own method but
	//in ArrayList, there are pre-defined methods

	//as seen just now, the generic methods and generic class in collections framework allows you to keep any kind of
	//data, different types of data

	//1. collection interface
	//2. Map interface


	//Collections .... is a class

	//Collection is a interface  (Collection by name indicates grouping of objects)

	//there are three interfaces in a collection interface -- very important point
	//1. List 2. Set 3. Queue
	//interface can extends interface in the same way classes do
	//interface A, interface B, interface B extends interface A
	//if some class C implements interface B, all the methods in interface A and B must be override in the Class C

	//1. List interface
	//classes that implements List interface directly are three classes
	//1. ArrayList 2. LinkedList 3. Vector (indirectly 4. Stack class is a child class of class Vector that implements List)
	//all these class have a defined data structure
	//advantage = duplication allowed

	//2. Set interface (two types, SortedSet, NavigableSet-(TreeSet is the implementing class))
	//HashSet, (LinkedHashSet is a child class of HashSet) are two implementing classes
	//no duplicates allowed

	//3. Queue


	//2. Map interface (SortedMap, NavigableMap -(TreeMap is the implementing class))
	//behind the scenes
	//objects are stored in key value pair (associated array)
	//Employee (FacultyAli) //Subjects (OOPBSEB) (grouped together) but
	//Employee (FacultyAli) //Subjects (OOPBSEA)
	//key must be unique, values can be changed

	//Utility classes are also provided in the collection framework
	//1. Collections
	//2. Arrays



	//Lab Assignment

	//1. Take an example of your own choice and apply the following: (Must not be from the Internet)
	//   1. LinkedList
	//   2. Set
	//   3. Map
	// Please comment as conclusion on your assignment. (Due date: 6th June, 2021 at 11:55PM)

	//Reminder of quiz on Tuesday InshaAllah
	//contents of the quiz (Exception, File Handling, Generic collections)


}




//  Generic By tim ( Udemy Course  After My practicing )
package Terminal;

import java.util.ArrayList;

public class App {
    public static void main(String[] args) {
        ArrayList<Integer> items = new ArrayList<>();
        items.add(1);
        items.add(2);
        items.add(3);
        //items.add("john");

        items.add(4);
        items.add(5);

        printDoubled(items);

    }
    private static void  printDoubled (ArrayList<Integer> n){
        // if we write in lower case object then there is an error
        // After writing integer in paramater place now you can run like this. they do by ownself autoboxing.
        //for (Object i : n ){
        for (int i : n ){
            System.out.println(( i * 2);
        }
    }
}

// Generic example by Tim ( player and footbal game code )

package Terminal;

public abstract class Player {
    private String name;

    public Player (String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
}
//
package Terminal;

public class BaseballPlayer extends Player{

    public BaseballPlayer(String name) {
        super(name);
    }
}
//
package Terminal;

public class FootballPlayer extends Player{
    public FootballPlayer(String name) {
        super(name);
    }
}
//
package Terminal;

public class SoccerPlayer extends Player{
    public SoccerPlayer(String name) {
        super(name);
    }
}

// Team class without generic


package Terminal;

import java.util.ArrayList;

public class Team {
    private String name;
    int played = 0 ;
    int won = 0 ;
    int lost = 0 ;
    int tied = 0;

    private ArrayList <Player> members = new ArrayList<>();

    public Team(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public boolean addPlayer (Player player){
        if (members.contains(player)){
            System.out.println(player.getName()+ "is already on this team");
            return false;
        } else {
            members.add(player);
            System.out.println(player.getName()+" picked for team "+ this.name);
            return true;


        }
    }
    public int numPlayers(){
        return this.members.size();
    }
    public void matchResult (Team opponent, int ourScore, int theirScore ){
        if (ourScore > theirScore){
            won ++;
        } else if(ourScore == theirScore){
            tied ++;
        }else {
            lost ++;
        }
        played ++;
        if (opponent != null){
            opponent.matchResult(null,theirScore,ourScore);
        }
    }
    public int ranking (){
        return ( won * 2) + tied;
    }
}

// Team class Using comparable interface and other generic classess
package Terminal;

import java.util.ArrayList;

import java.util.ArrayList;


public class Team<T extends Player> implements Comparable<Team<T>> {
    private String name;
    int played = 0;
    int won = 0;
    int lost = 0;
    int tied = 0;


    private ArrayList<T> members = new ArrayList<>();

    public Team(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public boolean addPlayer(T player) {
        if (members.contains(player)) {
            System.out.println(player.getName() + " is already on this team");
            return false;
        } else {
            members.add(player);
            System.out.println(player.getName() + " picked for team " + this.name);
            return true;
        }
    }

    public int numPlayers() {
        return this.members.size();
    }

    public void matchResult(Team<T> opponent, int ourScore, int theirScore) {

        String message;

        if(ourScore > theirScore) {
            won++;
            message = " beat ";
        } else if(ourScore == theirScore) {
            tied++;
            message = " drew with ";

        } else {
            lost++;
            message = " lost to ";
        }
        played++;
        if(opponent != null) {
            System.out.println(this.getName() + message + opponent.getName());
            opponent.matchResult(null, theirScore, ourScore);
        }
    }

    public int ranking() {
        return (won * 2) + tied;
    }

    @Override
    public int compareTo(Team<T> team) {
        if(this.ranking() > team.ranking()) {
            return -1;
        } else if(this.ranking() < team.ranking()) {
            return 1;
        } else {
            return 0;
        }
    }
}

// Mian class
package Terminal;

import java.util.ArrayList;
import java.util.Collections;

public class App {
    public static void main(String[] args) {
   FootballPlayer Ahmad = new FootballPlayer("Ahmad");
   BaseballPlayer hakeem = new BaseballPlayer ("hakeem");
   SoccerPlayer juma = new SoccerPlayer ("juma");

   Team<FootballPlayer>AfghanistanTiger  = new Team ("Afghanistan Tiger") ;

   AfghanistanTiger.addPlayer(Ahmad);
  // AfghanistanTiger.addPlayer(hakeem);
   //AfghanistanTiger.addPlayer(juma);

        System.out.println(AfghanistanTiger.numPlayers());

   Team<BaseballPlayer> baseballTeam = new Team <> ("Afghan club");
   baseballTeam.addPlayer(hakeem);

   Team<SoccerPlayer> brokenTeam = new Team <> ("This won't work");
   brokenTeam.addPlayer(juma);

   Team<FootballPlayer> melbourne = new Team<>("Melbourne ");
   FootballPlayer banks = new FootballPlayer("Gordon");
   melbourne.addPlayer(banks);

   Team<FootballPlayer> hawthorn = new Team<>("Hawthorn  ");
   Team<FootballPlayer> framentle = new Team<>("ramentle");

   hawthorn.matchResult(framentle,1,0);
   hawthorn.matchResult(AfghanistanTiger,3,8);

   AfghanistanTiger.matchResult(framentle,2,1);
  // AfghanistanTiger.matchResult(baseballTeam,1,1);
        System.out.println("Rankings");
        System.out.println(AfghanistanTiger.getName() + " " + AfghanistanTiger.ranking());
        System.out.println(melbourne.getName()+ " " + melbourne.ranking());
        System.out.println(framentle.getName() + " " + framentle.ranking());
        System.out.println(hawthorn.getName()+ " " + hawthorn.ranking());

        System.out.println(AfghanistanTiger.compareTo(melbourne));
        System.out.println(AfghanistanTiger.compareTo(hawthorn));
        System.out.println(hawthorn.compareTo(AfghanistanTiger));
        System.out.println(melbourne.compareTo(framentle));

        //ArrayList<Team> teams;
        //Collections.sort(teams);

    }
}

// Generic challenge ( most code from above project)
    // ArrayList<Team> teams;
        // Collections.sort(teams);
        // Create a generic class to implement a league table for a sport.
        // The class should allow teams to be added to the list, and store
        // a list of teams that belong to the league.
        //
        // Your class should have a method to print out the teams in order,
        // with the team at the top of the league printed first.
        //
        // Only teams of the same type should be added to any particular
        // instance of the league class - the program should fail to compile
        // if an attempt is made to add an incompatible team.


//
package com.timbuchalka;

/**
 * Created by dev on 17/10/2015.
 */
public abstract class Player {
    private String name;

    public Player(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
//
package com.timbuchalka;

/**
 * Created by dev on 17/10/2015.
 */
public class BaseballPlayer extends Player {
    public BaseballPlayer(String name) {
        super(name);
    }
}
//
package com.timbuchalka;

/**
 * Created by dev on 17/10/2015.
 */
public class FootballPlayer extends Player {

    public FootballPlayer(String name) {
        super(name);
    }
}

//
package com.timbuchalka;

/**
 * Created by dev on 17/10/2015.
 */
public class SoccerPlayer extends Player {

    public SoccerPlayer(String name) {
        super(name);
    }
}
//
package com.timbuchalka;

import java.util.ArrayList;
import java.util.Collections;

/**
 * Created by dev on 18/10/2015.
 */
public class League<T extends Team> {
    public String name;
    private ArrayList<T> league = new ArrayList<>();

    public League(String name) {
        this.name = name;
    }

    public boolean add(T team) {
        if(league.contains(team)) {
            return false;
        }
        league.add(team);
        return true;
   }

    public void showLeagueTable() {
        Collections.sort(league);
        for(T t : league) {
            System.out.println(t.getName() + ": " + t.ranking());
        }
    }
}
//
package com.timbuchalka;

import java.util.ArrayList;

/**
 * Created by dev on 17/10/2015.
 */
public class Team<T extends Player> implements Comparable<Team<T>> {
    private String name;
    int played = 0;
    int won = 0;
    int lost = 0;
    int tied = 0;


    private ArrayList<T> members = new ArrayList<>();

    public Team(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public boolean addPlayer(T player) {
        if (members.contains(player)) {
            System.out.println(player.getName() + " is already on this team");
            return false;
        } else {
            members.add(player);
            System.out.println(player.getName() + " picked for team " + this.name);
            return true;
        }
    }

    public int numPlayers() {
        return this.members.size();
    }

    public void matchResult(Team<T> opponent, int ourScore, int theirScore) {

        String message;

        if(ourScore > theirScore) {
            won++;
            message = " beat ";
        } else if(ourScore == theirScore) {
            tied++;
            message = " drew with ";

        } else {
            lost++;
            message = " lost to ";
        }
        played++;
        if(opponent != null) {
            System.out.println(this.getName() + message + opponent.getName());
            opponent.matchResult(null, theirScore, ourScore);
        }
    }

    public int ranking() {
        return (won * 2) + tied;
    }

    @Override
    public int compareTo(Team<T> team) {
        if(this.ranking() > team.ranking()) {
            return -1;
        } else if(this.ranking() < team.ranking()) {
            return 1;
        } else {
            return 0;
        }
    }
}

// main class
package com.timbuchalka;

public class Main {

    public static void main(String[] args) {

        League<Team<FootballPlayer>> footballLeague = new League<>("AFL");
        Team<FootballPlayer> adelaideCrows = new Team<>("Adelaide Crows");
        Team<FootballPlayer> melbourne = new Team<>("Melbourne");
        Team<FootballPlayer> hawthorn= new Team<>("Hawthorn");
        Team<FootballPlayer> fremantle= new Team<>("Fremantle");
        Team<BaseballPlayer> baseballTeam = new Team<>("Chicago Cubs");

        hawthorn.matchResult(fremantle, 1, 0);
        hawthorn.matchResult(adelaideCrows, 3, 8);

        adelaideCrows.matchResult(fremantle, 2, 1);

        footballLeague.add(adelaideCrows);
        footballLeague.add(melbourne);
        footballLeague.add(hawthorn);
        footballLeague.add(fremantle);

//        footballLeague.add(baseballTeam);
        footballLeague.showLeagueTable();

        BaseballPlayer pat = new BaseballPlayer("Pat");
        SoccerPlayer beckham = new SoccerPlayer("Beckham");
        Team rawTeam = new Team("Raw Team");
        rawTeam.addPlayer(beckham); // unchecked warning
        rawTeam.addPlayer(pat);     // unchecked warning

        footballLeague.add(rawTeam);     // unchecked warning

        League<Team> rawLeague = new League<>("Raw");
        rawLeague.add(adelaideCrows);     // no warning
        rawLeague.add(baseballTeam);    // no warning
        rawLeague.add(rawTeam);         // no warning

        League reallyRaw = new League("Really raw");
        reallyRaw.add(adelaideCrows);     // unchecked warning
        reallyRaw.add(baseballTeam);    // unchecked warning
        reallyRaw.add(rawTeam);         // unchecked warning



    }
}

// Collection Overveiw By Tim
package com.timbuchalka;

import java.util.*;

/**
 * Created by dev on 2/12/2015.
 */
public class Theatre {
    private final String theatreName;
    private List<Seat> seats = new ArrayList<>();

    public Theatre(String theatreName, int numRows, int seatsPerRow) {
        this.theatreName = theatreName;

        int lastRow = 'A' + (numRows -1);
        for (char row = 'A'; row <= lastRow; row++) {
            for(int seatNum = 1; seatNum <= seatsPerRow; seatNum++) {
                Seat seat = new Seat(row + String.format("%02d", seatNum));
                seats.add(seat);
            }
        }
    }

    public String getTheatreName() {
        return theatreName;
    }

    public boolean reserveSeat(String seatNumber) {
        Seat requestedSeat = null;
        for(Seat seat : seats) {
            if(seat.getSeatNumber().equals(seatNumber)) {
                requestedSeat = seat;
                break;
            }
        }

        if(requestedSeat == null) {
            System.out.println("There is no seat " + seatNumber);
            return false;
        }

        return requestedSeat.reserve();
    }

    // for testing
    public void getSeats() {
        for(Seat seat : seats) {
            System.out.println(seat.getSeatNumber());
        }
    }

    private class Seat {
        private final String seatNumber;
        private boolean reserved = false;

        public Seat(String seatNumber) {
            this.seatNumber = seatNumber;
        }

        public boolean reserve() {
            if(!this.reserved) {
                this.reserved = true;
                System.out.println("Seat " + seatNumber + " reserved");
                return true;
            } else {
                return false;
            }
        }

        public boolean cancel() {
            if(this.reserved) {
                this.reserved = false;
                System.out.println("Reservation of seat " + seatNumber + " cancelled");
                return true;
            } else {
                return false;
            }
        }

        public String getSeatNumber() {
            return seatNumber;
        }
    }


}

package com.timbuchalka;

public class Main {

    public static void main(String[] args) {
	    Theatre theatre = new Theatre("Olympian", 8, 12);
//        theatre.getSeats();
        if(theatre.reserveSeat("H11")) {
            System.out.println("Please pay");
        } else {
            System.out.println("Sorry, seat is taken");
        }
        if(theatre.reserveSeat("H11")) {
            System.out.println("Please pay");
        } else {
            System.out.println("Sorry, seat is taken");
        }
    }
}

// Map Interface By time
package com.timbuchalka;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by dev on 8/12/2015.
 */
public class MapProgram {

    public static void main(String[] args) {
        Map<String, String> languages = new HashMap<>();
        if(languages.containsKey("Java")) {
            System.out.println("Java already exists");
        } else {
            languages.put("Java", "a compiled high level, object-oriented, platform independent language");
            System.out.println("Java added successfully");
        }

        languages.put("Python", "an interpreted, object-oriented, high-level programming language with dynamic semantics");
        languages.put("Algol", "an algorithmic language");
        System.out.println(languages.put("BASIC", "Beginners All Purposes Symbolic Instruction Code"));
        System.out.println(languages.put("Lisp", "Therein lies madness"));

        if(languages.containsKey("Java")) {
            System.out.println("Java is already in the map");
        } else {
            languages.put("Java", "this course is about Java");
        }

        System.out.println("================================================");

        for(String key: languages.keySet()) {
            System.out.println(key + " : " + languages.get(key));
        }
    }
}




// Gui Lecture 1st  1 june_ 2021 by M- Ali Khan
package gui;

import javax.swing.*;


public class App extends JFrame{

	public static void main(String[] args) {

		//Graphical user interface
		//since it includes a main method, therefore, it can run independently (stand alone)
		//but, there exist some programs written in java that would need Internet to run
		//and these programs are usually embedded in HTML

		//There are two application program interface API (Pre-defined set of classes that do something for you)
		//1. AWT 	2. Swing

		//we are interested in Swing, because it is latest, extended version of AWT classes (child), and in use
		//AWT is depreciated, we mean that most of the support for its classes is no longer available

		JFrame jframe = new JFrame("Terminal Examination");

		jframe.setVisible(true);
		jframe.setSize(600, 600);

		//JFrame is a container class that serves as frame for the components
		//what is the difference between JFrame and Frame

		JLabel jl1 = new JLabel("Name : ");
		JLabel jl2 = new JLabel("Father Name : ");
		JLabel jl3 = new JLabel("Program : ");
		JLabel jl4 = new JLabel("Email : ");

		JTextField jt1 = new JTextField();
		JTextField jt2 = new JTextField();
		JTextField jt3 = new JTextField();
		JTextField jt4 = new JTextField();

		JButton jb1 = new JButton("New Student");
		JButton jb2 = new JButton("Present Student");

		jframe.setLayout(null);

		jl1.setBounds(50, 50, 100, 20);
		jl2.setBounds(50, 100, 100, 20);
		jl3.setBounds(50, 150, 100, 20);
		jl4.setBounds(50, 200, 100, 20);

		jt1.setBounds(150, 50, 300, 40);
		jt2.setBounds(150, 100, 300, 40);
		jt3.setBounds(150, 150, 300, 40);
		jt4.setBounds(150, 200, 300, 40);

		jb1.setBounds(150, 250, 140, 40);
		jb2.setBounds(310, 250, 140, 40);

		jframe.add(jl1);
		jframe.add(jl2);
		jframe.add(jl3);
		jframe.add(jl4);
		jframe.add(jt1);
		jframe.add(jt2);
		jframe.add(jt3);
		jframe.add(jt4);
		jframe.add(jb1);
		jframe.add(jb2);





	}

}

// Java Task  ( 3_ june - 2021 GUI)

package Terminal;

import javax.swing.*;

public class App extends JFrame {
public static void main(String[] args) {

        JFrame jFrame = new JFrame();

        JLabel userNameLabel = new JLabel("Username : ");
        JLabel passwordLabel = new JLabel("Password : ");
        JLabel cityOfEmploymentLabel = new JLabel("City of \nEmployment : ");
        JLabel webServerLabel = new JLabel("Web Server : ");
        JLabel roleLabel = new JLabel("<html><body>Please specify<br>your role : </body></html>");
        JLabel SSILabel = new JLabel("<html><body>Single sign on<br>to the following : </body></html>");

        JTextField userNameField = new JTextField();
        JTextField passwordField = new JTextField();
        JTextField employmentField = new JTextField();

        String[] servers = {"apache","xampp","tomcat"};
        JComboBox<String> webServerComBox = new JComboBox<>(servers);

        ButtonGroup buttonGroup = new ButtonGroup();
        JRadioButton rb1 = new JRadioButton("Admin");
        JRadioButton rb2 = new JRadioButton("Engineer");
        JRadioButton rb3 = new JRadioButton("Manager");
        JRadioButton rb4 = new JRadioButton("Guest");
        buttonGroup.add(rb1);
        buttonGroup.add(rb2);
        buttonGroup.add(rb3);
        buttonGroup.add(rb4);

        JCheckBox cb1 = new JCheckBox("Main");
        JCheckBox cb2 = new JCheckBox("Payroll");
        JCheckBox cb3 = new JCheckBox("Self-Service");

        JButton loginButton = new JButton("Login");
        JButton resetButton = new JButton("Reset");









        userNameLabel.setBounds(20,20,100,20);
        passwordLabel.setBounds(20,50,100,20);
        cityOfEmploymentLabel.setBounds(20,80,170,20);
        webServerLabel.setBounds(20,110,100,20);
        roleLabel.setBounds(20,165,170,50);
        SSILabel.setBounds(20,265,190,50);


        userNameField.setBounds(150,20,200,20);
        passwordField.setBounds(150,50,200,20);
        employmentField.setBounds(150,80,200,20);
        webServerComBox.setBounds(150,110,200,20);


        rb1.setBounds(150,150,140,20);
        rb2.setBounds(150,170,140,20);
        rb3.setBounds(150,190,140,20);
        rb4.setBounds(150,210,140,20);


        cb1.setBounds(150,260,140,20);
        cb2.setBounds(150,280,140,20);
        cb3.setBounds(150,300,140,20);


        loginButton.setBounds(150,350,70,25);
        resetButton.setBounds(280,350,70,25);







        jFrame.add(userNameLabel);
        jFrame.add(passwordLabel);
        jFrame.add(cityOfEmploymentLabel);
        jFrame.add(webServerLabel);
        jFrame.add(roleLabel);
        jFrame.add(SSILabel);

        jFrame.add(userNameField);
        jFrame.add(passwordField);
        jFrame.add(employmentField);
        jFrame.add(webServerComBox);

        jFrame.add(rb1);
        jFrame.add(rb2);
        jFrame.add(rb3);
        jFrame.add(rb4);

        jFrame.add(cb1);
        jFrame.add(cb2);
        jFrame.add(cb3);

        jFrame.add(loginButton);
        jFrame.add(resetButton);



        jFrame.setSize(500,500);
        jFrame.setLayout(null);
        jFrame.setVisible(true);
    }

}

// Give Bacground color

  jframe.getContentPane().setBackground(Color.GRAY); // jfram is the object name.


// Event Handling By M- Ali Khan ( 4_6_ 2021)

package eventHandling;

public class App {

	public static void main(String[] args) {

		//How to handle events in Java Swing?
		//for now, we will be focusing on button click event

		//event? //as a result of user interaction with the components of container, we expect components to do something
		//container, components (labels, text fields, frame, etc.....) they are actually objects
		//every object has a state and when that state changes, it is called an event
		//this change is as a result of user interaction with the components, container, etc...
		//when events occur, then they need to be handled
		//events (user interaction - foreground), (not user interaction - background - system, OS)

		//1. event (button click)
		//handling events in Java (there are 2 things)
		// 1. identify the source of event 2. You need to connect the source with the handler

		//three ways to handle the event
		//1. using a separate class
		//2. within a class
		//3. inner class
		//4. anonymous class


	}

}
// By Using A Separate( External ) class
package eventHandling;

import javax.swing.*;

public class Application {

	public static void main(String[] args) {

		JFrame jframe = new JFrame("Button click event");

		jframe.setLayout(null);
		jframe.setVisible(true);
		jframe.setSize(300, 300);

		JButton jb1 = new JButton("Login");
		JButton jb2 = new JButton("Register");

		jb1.setBounds(50, 50, 100, 25);
		jb2.setBounds(150, 50, 100, 25);
		jframe.add(jb1);
		jframe.add(jb2);

		jb1.setActionCommand("L1");
		jb2.setActionCommand("R2");

		//fire an event, information regarding event is stored in an object, component is identified by its text
		// when we pass an object then there is error come for removing this error we have to make new class and implement method of this interface.
		jb1.addActionListener(new BEventHandler());
		jb2.addActionListener(new BEventHandler());

	}

}

package eventHandling;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class BEventHandler implements ActionListener {

	@Override
	public void actionPerformed(ActionEvent e) {

		String val = e.getActionCommand();
		if (val.equals("L1")) {
			System.out.println("Login button is clicked.");
		}
		if (val.equals("R2")) {
			System.out.println("Register button is clicked.");
		}


	}

}
//  2 : By using Inner class
package Terminal;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class EventApp {
    public static void main(String[] args) {
        // By using Inner class
        // we make an object of first outer class then inner like you did in assignment.
        EventApp app = new EventApp();
       EventApp.BForEventApp obj = app.new BForEventApp();

        JFrame jframe = new JFrame("Button Click Event");

        jframe.setLayout(null);
        jframe.setVisible(true);
        jframe.setSize(300, 300);

        JButton jb1 = new JButton("Login ");
        JButton jb2 = new JButton("Register");

        jb1.setBounds(50, 50, 100, 25);
        jb2.setBounds(150, 50, 100, 25);


        jframe.add(jb1);
        jframe.add(jb2);

        jb1.setActionCommand("L1");
        jb2.setActionCommand("R2");
        //fire an event, information regarding event is stored in an object, component is identified by its textjb1.addActionListener(obj);
        // we create a class by some name like BForEventApp and within this file and then we create an object of outer class then inner class.
       jb1.addActionListener(obj);
       jb2.addActionListener(obj);

    }
    private class BForEventApp implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
           String val = e.getActionCommand();
           if (val.equals("L1")){
               System.out.println("Login button is clicked.");
           }
           if(val.equals("R2")){
               System.out.println("Register button is clicked.");
           }

        }
    }
}



// 3rd way within a class handling
package Terminal;

import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Application2 implements ActionListener {
    JTextField jt1 = new JTextField();
    public static void main(String[] args) {
    Application2 App2 = new Application2();
    }
    // for accessing constructor we make an object.
    public Application2() {
        JFrame jframe = new JFrame("Button ");

        jframe.setLayout(null);
        jframe.setVisible(true);
        jframe.setSize(300, 300);

        JButton jb1 = new JButton("Login");
        JButton jb2 = new JButton("Register");



        jb1.setBounds(50, 50, 100, 25);
        jb2.setBounds(150, 50, 100, 25);
        jt1.setBounds(70, 80, 100, 20);
        jframe.add(jb1);
        jframe.add(jb2);
        jframe.add(jt1);

        jb1.setActionCommand("L1");
        jb2.setActionCommand("R2");

        //fire an event, information regarding event is stored in an object, component is identified by its text
        // this mean that method is within a class
        jb1.addActionListener(this);
        jb2.addActionListener(this);
    }


    @Override
    public void actionPerformed(ActionEvent e) {
        String val = e.getActionCommand();
        if (val.equals("L1")) {
            //from jb1 they know from this object but they don't know about jt1
            jt1.setText("Login");
            System.out.println("Login button is clicked.");
        }
        if (val.equals("R2")) {
            jt1.setText("Register");
            System.out.println("Register button is clicked.");
        }

    }
}

// can you call a nonstatic method from a static method ? ans : No you can not.
// this you can't used in static context. so for this purpose we out this code from static and make a seperate method.(there is also problem)

//then  there is also problem of static so we can't call nonstatic method from static. so for this we make a constructor and put all code in constructor


//KeyEvent Handler Example  (using separate class);

package Terminal;

import javax.swing.*;

public class KeyApp {
    // globally access
    JFrame jframe;
    JTextField jt1;
    JLabel jl1;

    public static void main(String[] args) {
        KeyApp app = new KeyApp();
    }
    public KeyApp(){
        frame();

    }
    public  void frame(){
        jframe = new JFrame("Key Event ");
        jframe.setLayout(null);
        jframe.setVisible(true);
        jframe.setSize(300,300);

        jt1 = new JTextField();
        jl1 = new JLabel();

        jl1.setText("Nothing happening..");

        jt1.setBounds(50, 50, 100, 35);
        jl1.setBounds(50, 200, 200, 50);

        jframe.add(jl1);
        jframe.add(jt1);

        //fire an event, information regarding event is stored in an object, component is identified by its text
        jt1.addKeyListener(new KeyEventHandlerr());
    }
}

// keyEventHandler class which is own maked when we pass an object.
package Terminal;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class KeyEventHandlerr implements KeyListener {
    @Override
    public void keyTyped(KeyEvent e) {
        System.out.println("Typing");
    }

    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Key pressed");
    }

    @Override
    public void keyReleased(KeyEvent e) {
        System.out.println("Key Released");
    }
}


// Key event handling program by using within the class.
package Terminal;

import javax.swing.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class KeyApp {
    JFrame jframe;
    JTextField jt1;
    JLabel jl1;

    public static void main(String[] args) {
        KeyApp app = new KeyApp();
    }
    public KeyApp(){
        frame();

    }
    public  void frame(){
        jframe = new JFrame("Key Event ");
        jframe.setLayout(null);
        jframe.setVisible(true);
        jframe.setSize(300,300);

        jt1 = new JTextField();
        jl1 = new JLabel();

        jl1.setText("Nothing happening..");

        jt1.setBounds(50, 50, 100, 35);
        jl1.setBounds(50, 200, 200, 50);

        jframe.add(jl1);
        jframe.add(jt1);

        //fire an event, information regarding event is stored in an object, component is identified by its text
        jt1.addKeyListener(new KeyEventHandlerr());
    }

    private class KeyEventHandlerr implements KeyListener{

        @Override
        public void keyTyped(KeyEvent e) {
            System.out.println("Typing");
        }

        @Override
        public void keyPressed(KeyEvent e) {
            System.out.println("Pressing Keys...");
        }

        @Override
        public void keyReleased(KeyEvent e) {
            System.out.println("Not Typing");
        }
    }
}


//  4) Handling Event by using Anonymoust class.

package Terminal;

import javax.swing.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class keyAnonymousApp {
    JFrame jframe;
    JTextField jt1;
    JLabel jl1;

    public static void main(String[] args) {

    }
    public keyAnonymousApp(){
        frame();
    }
    public void frame(){
        jframe = new JFrame("Key Event");

        jframe.setLayout(null);
        jframe.setVisible(true);
        jframe.setSize(300, 300);

        jt1 = new JTextField();
        jl1 = new JLabel();
        jl1.setText("Nothing happening..");

        jt1.setBounds(50, 50, 100, 35);
        jl1.setBounds(50, 200, 200, 50);

        jframe.add(jl1);
        jframe.add(jt1);

        // Anonymousley
        jt1.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
                System.out.println("Typing..");
            }

            @Override
            public void keyPressed(KeyEvent e) {
                System.out.println("Key pressed");

            }

            @Override
            public void keyReleased(KeyEvent e) {
                System.out.println("Key released .. ");
            }
        });
        //   Used above class and do Fucus listner event (you can see oracle and totorial point for more details.)
        // add fucus do ex practice.. used 2 faild other for that (you can see pic from screen shot) .. and one faild used anonymous class
        // add fucuslistner..


        // we did button ,fucus and key..
        // imp is that: we did individtual  make that kind of ex which include
        // multiple thing like text button labale takes three faild.
        // like that takes three faild faild 2 fild 2 faild lable result
       // make ex like calculator




    }
}



// Layout  in GUI By Sir M- Ali khan    on 8-06-021

	// Graphical user interface
		// 1. Introduction to JFC (Java Foundation classes)
		// 2. AWT and SWING
		// 3. Introduction to SWING
		// 4. container and components
		// 5. container - JFrame, JPanel
		// 6. components - JButtons, JTextField, JLabel, JCombo....
		// 7. custom layout - set bounds
		// 8. event handling - button click, key event, focus event, text event etc.
		// 9. layouts (today's agenda)
		// 9.1. BorderLayout
		// 9.2. FlowLayout
		// 9.3. GridLayout
		// 9.4. GridBagLayout
		// 10. JTables (on Thursday inshaAllah)
		// 11. Java and JDBC (Friday full session) - connection, CRUD - (Optional)

// 1) Border Layout
package Terminal;

import javax.swing.*;
import java.awt.*;

public class App {

    public static void main(String[] args) {
        //layouts
        //layout is an object that helps you arrange components on container in different ways
        //1. BorderLayout
        //it is used when you need to arrange components on a container at the borders (North, South, East, West)
        //it is more useful in the case of JPanel
        //Important point  1) when you declare setLayout (pass object of new border layout.)
        //2) use setprefared size and pass new dimension width and hight. 3)and also give background color.
        // 4) when you want to add to frame and give property to border layout lik east,west, North, South
        JFrame jframe = new JFrame("Border Layout");

        jframe.setVisible(true);
        jframe.setSize(400,400);

        jframe.setLayout(new BorderLayout());

        JPanel jp1 = new JPanel();
        jp1.setBackground(Color.black);
        jp1.setPreferredSize(new Dimension(50,50));

        JPanel jp2 = new JPanel();
        jp2.setBackground(Color.blue);
        jp2.setPreferredSize(new Dimension(100,50));

        JPanel jp3 = new JPanel();
        jp3.setBackground(Color.red);
        jp3.setPreferredSize(new Dimension(50,50));

        JPanel jp4= new JPanel();
        jp4.setBackground(Color.green);
        jp4.setPreferredSize(new Dimension(100,50));

        JPanel jp5 = new JPanel();
        jp5.setBackground(Color.CYAN);
        jp5.setPreferredSize(new Dimension(100,50));

        jframe.add (jp1,BorderLayout.NORTH);
        jframe.add(jp2,BorderLayout.SOUTH);
        jframe.add(jp3,BorderLayout.EAST);
        jframe.add(jp4,BorderLayout.WEST);
        jframe.add(jp5,BorderLayout.CENTER);

        //2) Flow Layout
        package Terminal;

import javax.swing.*;
import java.awt.*;

public class App {

    public static void main(String[] args) {
       // FlowLayout
        // Imp Points: 1)  when you declare Layout write syntax like that: jframe.setLayout(new FlowLayout(FlowLayout.RIGHT));
        JFrame jframe = new JFrame("FlowLayout Layout");

        jframe.setVisible(true);
        jframe.setSize(400,400);

        jframe.setLayout(new FlowLayout(FlowLayout.RIGHT));

        JButton jb1 = new JButton("Login");
        JButton jb2 = new JButton("Login");
        JButton jb3 = new JButton("Login");
        JButton jb4 = new JButton("Login");
        JButton jb5 = new JButton("Login");
        JButton jb6 = new JButton("Login");
        JButton jb7 = new JButton("Login");
        JButton jb8 = new JButton("Login");


        jframe.add(jb1);
        jframe.add(jb1);
        jframe.add(jb2);
        jframe.add(jb3);
        jframe.add(jb4);
        jframe.add(jb5);
        jframe.add(jb6);
        jframe.add(jb7);
        jframe.add(jb8);

// Grid Layout
package Terminal;

import javax.swing.*;
import java.awt.*;

public class App {

    public static void main(String[] args) {
       // GridLayout
        // Imp Points: 1)  when you declare Layout write syntax like that: jframe.setLayout(new GridLayout (3,3,4,4));
        JFrame jframe = new JFrame("Grid  Layout");

        jframe.setVisible(true);
        jframe.setSize(400,400);

        jframe.setLayout(new GridLayout (3,3,4,4));// give parameter for roww ,col,hgap, and vgap
        jframe.setLayout(new GridLayout (3,3));// you can only pass rows and col as well.
        JButton jb1 = new JButton("Login");
        JButton jb2 = new JButton("Login");
        JButton jb3 = new JButton("Login");
        JButton jb4 = new JButton("Login");
        JButton jb5 = new JButton("Login");
        JButton jb6 = new JButton("Login");
        JButton jb7 = new JButton("Login");
        JButton jb8 = new JButton("Login");


        jframe.add(jb1);
        jframe.add(jb1);
        jframe.add(jb2);
        jframe.add(jb3);
        jframe.add(jb4);
        jframe.add(jb5);
        jframe.add(jb6);
        jframe.add(jb7);
        jframe.add(jb8);









package layouts;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;

import javax.swing.*;

public class App {

	public static void main(String[] args) {

		//layouts
		//layout is an object that helps you arrange components on container in different ways

		JFrame jframe = new JFrame("Border Layout");

		jframe.setVisible(true);
		jframe.setSize(400, 400);


		// 4. GridBagLayout

		jframe.setLayout(new GridBagLayout());

		GridBagConstraints gbc = new GridBagConstraints();

		JButton jb1 = new JButton("Login1");
		gbc.gridx = 0;
		gbc.gridy = 0;
		jframe.add(jb1,gbc);

		JButton jb2 = new JButton("Login2");
		gbc.gridx = 1;
		gbc.gridy = 1;
		jframe.add(jb2,gbc);

		JButton jb3 = new JButton("Login3");
		gbc.gridx = 0;
		gbc.gridy = 3;
		jframe.add(jb3,gbc);

		JButton jb4 = new JButton("Login4");
		gbc.gridx = 4;
		gbc.gridy = 3;
		jframe.add(jb4,gbc);

		4) GridBag Layout
		package Terminal;

import javax.swing.*;
import java.awt.*;

public class App {

    public static void main(String[] args) {
       // FlowLayout
        /* Imp Points:  this 5 thing is imp in this layout
        1) jframe.setLayout(new GridBagLayout());

        2)GridBagConstraints gbc = new GridBagConstraints();

        3)JButton jb1 = new JButton("Login 1");
        4)gbc.gridx = 0;
        5)gbc.gridy = 0;
        jframe.add(jb1,gbc);
         */
        JFrame jframe = new JFrame("GridBag  Layout");

        jframe.setVisible(true);
        jframe.setSize(400,400);

        jframe.setLayout(new GridBagLayout());

        GridBagConstraints gbc = new GridBagConstraints();

        JButton jb1 = new JButton("Login 1");
        gbc.gridx = 1;
        gbc.gridy = 0;
        jframe.add(jb1,gbc);

        JButton jb2 = new JButton("Login 2");
        gbc.gridx = 1;
        gbc.gridy = 1;
        jframe.add(jb2,gbc);

        JButton jb3 = new JButton("Login 3");
        gbc.gridx = 2;
        gbc.gridy = 1;
        jframe.add(jb3,gbc);

        JButton jb4 = new JButton("Login 4");
        gbc.gridx = 2;
        gbc.gridy = 2;
        jframe.add(jb4,gbc);



// JDBC in java Explaination by M- Ali khan  before this you must do install this All students are required to have XAMPP installed on their machines for tomorrows lecture inshaAllah. Just type in XAMPP in google and follow the link for download. Do not install it in drive C. Any other drive is fine. Also, download MySQL java connector and unzip it.
package jdbc;

import java.sql.*;

public class Details {

	// JDBC - Java Database Connectivity API
	// 1. java.sql	2. javax.sql (packages - they include set of predefined classes)
	// these APIs are used to interact with the database

	// database is a place where you keep data in an organized way(DBMS)
	// 1. XAMPP - (X - cross platform, A - Apache (is like a transporter of your queries to database from your
	// 				java application, M - (MySQL - database - why? because its free), P - PHP, P -PERL)
	// Apache and MySQL are services and needs to be run/enabled before using it in java application

	// Java	(makes use of JDBC API - DriverManager class -- Driver program (java/MySQL connector)
	//																				---Interaction---	Database)
	// there are two types of libraries (1. standard (java automatically includes libraries)
	// 									 2. non-standard - for example, MySQL Java connector)

	// when you want to interact with the database, you need to establish a connection with the database
	// establishing a connection requires three important information
	// 1. User name (database - be default, user name - root)
	// 2. Password (by default, root password -- "") - empty
	// 3. database information (to which database you want to connect)

	// DB name - (undergraduate)
	// user name - root
	// password -




	// whenever we are making a connection to the database,
	// 1. first step is to load drivers
	// those drivers that will enable you to connect to the database

	// Application JDBC (CRUD - create (insert), retrieve (view), update, delete)
	// Statement class (purpose is to create an object that will carry SQL queries to the database)
	// Statement class to be used in conjunction with Connection class (createStatement method)

	// executeUpdate  --- insert, delete, update  -- as a argument accepts SQL query as a string
	// executeQuery --- view (Fetch record from database)



}

//
package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class App {

	public static void main(String[] args) throws SQLException {

		Connection connection = null;

		String username = "root";
		String password = "";
		String uri = "jdbc:mysql://localhost/undergraduate";

		try {
			Class.forName("com.mysql.cj.jdbc.Driver");
			connection = DriverManager.getConnection(uri, username, password);
			System.out.println("Connected to the database.");
		} catch (ClassNotFoundException e) {
			System.out.println("Dear user, plz try again later.");
		} catch (SQLException e) {
			System.out.println("Cannot connect to the database.");
		}
		finally {
			System.out.println("Connection to the database closed.");
			connection.close();
		}

	}

}
//   2nd part applaying crud operation on the above operation ( go to w3 school website and read the syntax off create, read ,delete and update and retrive syntax.)

package jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class App {

	public static void main(String[] args) throws SQLException {

		Connection connection = null;

		String username = "root";
		String password = "";
		String uri = "jdbc:mysql://localhost/undergraduate";


		try {
			Class.forName("com.mysql.cj.jdbc.Driver");
			connection = DriverManager.getConnection(uri, username, password);
			System.out.println("Connected to the database.");

			Statement statement = connection.createStatement(); //creates a statement object

			// delete record

		/*	String deleteRecord = "delete from student where program = 'Mathematics' and studentName = 'Ali'";
			statement.executeUpdate(deleteRecord);
			System.out.println("Record deleted");*/

			// retrive record

			System.out.println("Fetching records....");

			String viewRecord = "Select * from student";
			ResultSet result = statement.executeQuery(viewRecord); //result will come in form of array

			while(result.next()){
	            //Display values
	            System.out.println("Student Name : " + result.getString("studentName"));
	            System.out.println("Program : " + result.getString("program"));
	            System.out.println("Semester : " + result.getInt("semester"));
	         }


			// update record

			/*String updateQuery = "update student set program = 'Management Sciences' where studentName = 'Ahmad' and semester = 3 ";
			statement.executeUpdate(updateQuery);
			System.out.println("Record updated.");*/

			//Insert record
			/*  String insertQuery = "insert into student (studentName, program, semester) values ('Usman','Computer Science',2)";
			statement.executeUpdate(insertQuery);
			System.out.println("Record inserted.");*/

		} catch (ClassNotFoundException e) {
			System.out.println("Dear user, plz try again later.");
		} catch (SQLException e) {
			System.out.println("Cannot connect to the database.");
		}
		finally {
			System.out.println("Connection to the database closed.");
			connection.close();
		}

	}

}

// Practice For Termninal

// Static and instance method ex you can see  in word file which is save in sp21 java
package Terminal;
class Dog{
    public void bark() {//instance method
        System.out.println("woof");
    }

}
    class Calculator {
        public static void printSum(int a, int b) {// static method
            System.out.println("sum = " + (a + b));
        }
    }

public class Main {

    public static void main(String[] args) {

        Dog Golter = new Dog();// create instance for instance method other than instance all method is instance
        Golter.bark();

        Calculator.printSum(5,6);


    }


}

// in this lec we will talk about static and non static variable

// * instance varible and instance method we must instatiote( create an objects)
//*  for static method you don't need to create an object just className.variable or method  it is also behave as a class level
package Terminal;


// Static and Non static variable
class Dog{
   // private static String name;// for the declariton of static used classname.variable name
    private  String name;

    public Dog(String name){
       // Dog.name= name;
        this.name= name;// when you are not use static variable then initiolization must be by using this keyword.
    }
    public void PrintName (){
        System.out.println("name=  " +name);

    }
}
public class Main {
    public static void main(String[] args) {

        Dog Golter = new Dog("Golter");
        Dog puppy = new Dog("puppy");
        Golter.PrintName();
        puppy.PrintName();




    }


}

// static  block
package Terminal;

// static block is a block of code prifixed by "static " keyword
// gets executed only once
// used to initialize static variable.
public class Main {

    static int x;
    static {
        x =  10;
    }

    public static void main(String[] args) {
        System.out.println("x values is : " + x);
    }
}

// output is : x values is  : 10
// static block second ex
//JVM executes static blocks before the main method at the time of class loading.
package Terminal;


public class Main {

    static  int x = 10;
    static final  int x = 10;//  static block final varible
    static int y;
    static  void call (int p){
        System.out.println("X values is : "+ x);
        System.out.println("y values is : "+ y);
        System.out.println("p values is : "+ p);
    }
    static {
        System.out.println("static block initilized ");
        y = x *2;
    }

    public static void main(String[] args) {
       call (30);
    }
}

// Non static block in java
package Terminal;
// non static block or instance initilization block
// JVM executes static blocks before the main method at the time of class loading.
public class Student {
    String name;
    int age;
    {
        name = "Krishna";
        age = 25;

    }
    // you can use multiple nonstatic block in program
    {
        System.out.println("Initialization block or non static block");
    }

    public static void main(String[] args) {
     Student std = new Student();
     System.out.println("name = " + std.name);
     System.out.println("age = " + std.age);

    }
}

//
package Terminal;

// Final variables
// syntax : final type constName = value;

//Example
// final int FILE_NEW = 1;
//final float p1 = 3.141519;
public class Application {
    final int X = 10;
    public static void main(String[] args) {
        Application app = new Application();
        System.out.println( "X is = " + app.X);


    }
}

// wrong Program

public class B {
    final int X = 10;
    public static void main(String[] args) {
        X = 20// mean that final variable values cannot be changed.
        Application app = new Application();
        System.out.println( "X is = " + app.X);


    }
}

// Keep in mind Final method can be inherited but cannot be override it
// and final class cannot be extend it.

// you can declare any parameter as a final but you cannot change the value of it.
ex:
     int cube (final int n){
         n  = n + 2 ; // but you cab't be changed as n is final
         n*n*n;
     }

     // keep in mind we can't declare constructor as a final b/c constructor in never inherited

package Terminal;
// this invoke current class method
public class Application {

    void m(){
        System.out.println("Hello m");
    }
void n(){
    System.out.println("hello n");
    this.m();
}


    public static void main(String[] args) {

        Application app = new Application();
        app.n();

    }
}


package Terminal;

// this mainly used to differentiate b/w instance variable and local variable.
// this() : to invoke current class constructor
//Calling default constructor from parameterized constructor:
public class Application {

    Application(){
        System.out.println("Hello m");
    }
    Application (int x){
        this();
        System.out.println(x);
    }

    public static void main(String[] args) {
        Application app = new Application(10);

    }
}


//  Array in java
package Terminal;
// initilization of array
//int a [] = new int [4];

// actuall declaration

int [] array = new int [5];

public class Application {

    public static void main(String[] args) {
        int jersey [] = new int [] {1,2,3,4,5,6};

//        for (int i = 0; i<jersey.length; i++){
//            System.out.println(jersey[i]);
        for (int x : jersey){
            System.out.println(x);
        }

    }
}


    //  Declaration OF Multi Dimension Arrays
        //int a [][] = new int [2][3];
        int [][] dArray   = new int [2][3];
        dArray [0][0] = 1;
        dArray [0][1] = 2;
        dArray [0][2] = 3;

        dArray [1][0] = 9;
        dArray [1][1] = 8;
        dArray [1][2] = 7;
        // we must used nested loops to access the values or elements in an array.
       for (char s = 0 ; s< dArray.length; s++){
           for(int e = 0; e<dArray[s].length; e++)
           System.out.println(dArray[s][e]);
       }


    }
}

     // irregular Dimension arrays

        int [][] B = new int [3] []; //irreg two Dimensio
        int [][] C = new int [3][5];// regular array


    }
}

package Terminal;

import java.util.ArrayList;

public class Application {

    public static void main(String[] args) {
// ArrayList
        ArrayList <Integer> list = new ArrayList<Integer>();

        list.add(5);
        list.add(6);

        // TO add in a specific index

        list.add(0,24);// first is index no second is value

       // System.out.println(list.get(0));

        // we can used for each loop

        for (int x: list){
            System.out.println(x);
        }


    }
}


package Terminal;
//  Autoboxing: converting of primitive type into his corresponding wrapper class like int to Integer and etc.
public class Application {

    public static void main(String[] args) {

        int a = 20;
        //char c = 'c';
        Integer i = Integer.valueOf(a); // converting int into Integer Explicitly
       // char c = Character.valueOf(c);

        Integer j = a; //autoboxing , now compiler will write Integer.valueOf(a) internally.

        System.out.println(a+ " " +i+ " "+j);

    }
}

package Terminal;
 // Unboxing: automatic conversion of wrapper type into its corresponding primitive type is known as unboxing.
// it is the reverse process of autoboxing.
public class Application {

    public static void main(String[] args) {

        Integer a = new Integer(3); // converting Integer to int

        int i = a.intValue();// Converting Integer to int explicitly.
        int j = a;// Unboxing, now compiler will write a.intValue() internally.

        System.out.println(a + " " +i+ " "+j);


    }
}


//Java Wrapper classes wrap the primitive data types, that is why it is known as wrapper classes. We can also create a class which wraps a primitive data type. So, we can create a custom wrapper class in Java.

package Terminal;
// Super Keyword usage


class SuperClass{
     public void printMethod(){
         System.out.println("Printed in super class");
     }
 }

 class SubClass extends SuperClass{
     public void printMethod (){
         super.printMethod();
         System.out.println("Printed in subclass");
     }
 }
public class Application {

    public static void main(String[] args) {

        SubClass s = new SubClass();
        s.printMethod();




    }
}

/*Key Differences Between Data Hiding and Encapsulation
Encapsulation deals with hiding the complexity of a program. On the other hand, data hiding deals with the security of data in a program.
Encapsulation focuses on wrapping (encapsulating) the complex data in order to present a simpler view for the user. On the other hand, data hiding focuses on restricting the use of data, intending to assure the data security.
In encapsulation data can be public or private but, in data hiding, data must be private only.
Data hiding is a process as well as a technique whereas, encapsulation is subprocess in data hiding.

Conclusion:
I conclude by saying that data hiding and encapsulation both are important in an implementation of a system.
Both go hand in hand where data hiding focuses on the security of data,
the encapsulation focuses on reducing the complexity of the system in order to make the application more user-friendly.


*/

/* Object : is a an entity which has states and behaviour as known as objects : ex: chair, bike,marker , pen it can be phasical or logical (tangible or intangible)
 ex of intangible is banking system.
 object have three charactristic  1) state 2) Behavoiur 3) identity.

 Ex Of Objects in Java: Pen is an Object . its name is paino . color blue etc know as it's state it is used to write
 , so writing is its behavior.

 Object is an instance of a class : class is a template or blueprint from which objects are created.So Object is the instance (result of a class)

Class in java: is a group of Objects that has common properties. it is a template or blueprint from which object are created.

A class in java contain : 1 ) Data Member 2) Method 3)Constructor 4) Block 5) Class and Interface.

A class is a collection of fields(data) and methods (procedure or , function) tha operate on that data. */

// inheritance example
package Terminal;

class parent {
    public void p1(){
        System.out.println("parent method");
    }
}

class child extends parent{
    public void c1(){
        System.out.println("Child method");
    }
}
public class Application {

    public static void main(String[] args) {
        child cobj = new child();
        cobj.c1();
        cobj.p1();





    }
}





// Sir Asif shehzad Task:
// Bank Account Class
public class BankAccount{

    private double balance;
    private String name;
	private int depositsCount;
	private int withdrawsCount;

	public BankAccount(double balance, String name){
		if(balance > 0)
			this.balance = balance;
		this.name = name;
	}

    void deposit(double amount){
		if(balance >= 100000)
			amount = (amount) + ((amount) * (1/100.0));
        balance += amount;
		depositsCount++;
    }

    void withdraw(double amount){
		if(balance < 50000)
			amount = (amount) + ((amount)*(2.0/100.0));
        balance -= amount;
		withdrawsCount++;
    }

	public int getDepositsCount(){
		return depositsCount
	}

	public int getWithdrawsCount(){
		return withdrawsCount;
	}

	public double getBalance(){
		return balance;
	}

	public String getName(){
		return name;
	}
}


// BankAccount Test Class
import java.util.Scanner;

public class BankAccountTest{

    public static void main(String[] args){

        Scanner input = new Scanner(System.in);
        System.out.println("Enter account name >");
        String accountname = input.nextLine();

        System.out.println("Enter the balance in your account > ");
        double initialbalance = input.nextDouble();

		BankAccount bankAccount = new BankAccount(initialbalance, name);
		int menuOption = 0;

        do {
			System.out.println("Press 1: To Deposit an amount");
			System.out.println("Press 2: To Withdraw an amount");
			System.out.println("Press 3: To View the current balance");
			System.out.println("Press 4: To Close this program");
			menuOption = input.nextInt();

			switch(menuOption){
				case 1:
					bankAccount.deposit(getAmount());
					break;

				case 2:
					if(bankAccount.balance < 50000){
				   		System.out.println(
						"As you sure you want to withdraw, it would make your " +
						"balance below 50,000. Press 1 to continue and 0 to abort");

						if(input.nextInt() == 0 ) continue;
					}
					bankAccount.withdraw(getAmount());
					break;

				case 3:
					System.out.println("Your balance is =" + bankAccount.balance);
					break;
			}
        } while( menuOption != 4);

        System.out.println("Account Title:" + bankAccount.getName());
        System.out.println("Total deposits:" + bankAccount.getDepositsCount());
        System.out.println("Total withdraws:" + bankAccount.getWithdrawsCount());
        System.out.println("Balance:" + bankAccount.getBalance());
    }

	public static double getAmount(){
		Scanner input = new Scanner(System.in);
		System.out.println("Enter the amount > ");
		double amount = input.nextDouble();
		return amount;
	}
}



























